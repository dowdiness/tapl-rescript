// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__List from "@rescript/core/src/Core__List.bs.mjs";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";
import * as Belt_MapString from "rescript/lib/es6/belt_MapString.js";
import * as Belt_SetString from "rescript/lib/es6/belt_SetString.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

var NoRuleApplies = /* @__PURE__ */Caml_exceptions.create("LambdaCompile.Lam.NoRuleApplies");

var c = {
  contents: -1
};

function fresh(str) {
  c.contents = c.contents + 1 | 0;
  return str + c.contents.toString();
}

function go(env) {
  return function (t) {
    switch (t.TAG) {
      case "Int" :
          return {
                  TAG: "Int",
                  _0: t._0
                };
      case "Var" :
          var name$p = Belt_MapString.get(env, t._0);
          if (name$p !== undefined) {
            return {
                    TAG: "Var",
                    _0: name$p
                  };
          }
          throw {
                RE_EXN_ID: NoRuleApplies,
                _1: t,
                Error: new Error()
              };
      case "Lam" :
          var name = t._0;
          var name$p$1 = fresh(name);
          var env$p = Belt_MapString.set(env, name, name$p$1);
          return {
                  TAG: "Lam",
                  _0: name$p$1,
                  _1: go(env$p)(t._1)
                };
      case "App" :
          return {
                  TAG: "App",
                  _0: go(env)(t._0),
                  _1: go(env)(t._1)
                };
      case "Bop" :
          return {
                  TAG: "Bop",
                  _0: t._0,
                  _1: go(env)(t._1),
                  _2: go(env)(t._2)
                };
      case "If" :
          return {
                  TAG: "If",
                  _0: go(env)(t._0),
                  _1: go(env)(t._1),
                  _2: go(env)(t._2)
                };
      
    }
  };
}

var rename = go(undefined);

var Lam = {
  NoRuleApplies: NoRuleApplies,
  c: c,
  fresh: fresh,
  rename: rename
};

function mkHalt(v) {
  return {
          TAG: "Halt",
          _0: v
        };
}

function letStar(f, k) {
  return f(k);
}

function go$1(e, k) {
  switch (e.TAG) {
    case "Int" :
        return k({
                    TAG: "AtomInt",
                    _0: e._0
                  });
    case "Var" :
        return k({
                    TAG: "AtomVar",
                    _0: e._0
                  });
    case "Lam" :
        var f = fresh("f");
        var t$p = go$1(e._1, (function (v) {
                return {
                        TAG: "Halt",
                        _0: v
                      };
              }));
        return {
                TAG: "Fun",
                _0: f,
                _1: {
                  hd: e._0,
                  tl: /* [] */0
                },
                _2: t$p,
                _3: k({
                      TAG: "AtomVar",
                      _0: f
                    })
              };
    case "App" :
        var x = e._1;
        var f$1 = e._0;
        var __x = function (fAtom) {
          return (function (__x) {
                      return go$1(x, __x);
                    })(function (xAtom) {
                      switch (fAtom.TAG) {
                        case "AtomVar" :
                            var r = fresh("r");
                            return {
                                    TAG: "App",
                                    _0: r,
                                    _1: fAtom._0,
                                    _2: {
                                      hd: xAtom,
                                      tl: /* [] */0
                                    },
                                    _3: k({
                                          TAG: "AtomVar",
                                          _0: r
                                        })
                                  };
                        case "AtomInt" :
                        case "AtomGlob" :
                            return PervasivesU.failwith("Must apply named value!");
                        
                      }
                    });
        };
        return go$1(f$1, __x);
    case "Bop" :
        var y = e._2;
        var x$1 = e._1;
        var op = e._0;
        var __x$1 = function (xAtom) {
          return (function (__x) {
                      return go$1(y, __x);
                    })(function (yAtom) {
                      var r = fresh("r");
                      return {
                              TAG: "Bop",
                              _0: r,
                              _1: op,
                              _2: xAtom,
                              _3: yAtom,
                              _4: k({
                                    TAG: "AtomVar",
                                    _0: r
                                  })
                            };
                    });
        };
        return go$1(x$1, __x$1);
    case "If" :
        var f$2 = e._2;
        var t = e._1;
        var e$1 = e._0;
        var __x$2 = function (eAtom) {
          var j = fresh("j");
          var p = fresh("p");
          var joinVar_1 = {
            TAG: "AtomVar",
            _0: p
          };
          var joinVar = {
            TAG: "Jump",
            _0: j,
            _1: joinVar_1
          };
          return {
                  TAG: "Join",
                  _0: j,
                  _1: p,
                  _2: k({
                        TAG: "AtomVar",
                        _0: p
                      }),
                  _3: {
                    TAG: "If",
                    _0: eAtom,
                    _1: go$1(t, (function (param) {
                            return joinVar;
                          })),
                    _2: go$1(f$2, (function (param) {
                            return joinVar;
                          }))
                  }
                };
        };
        return go$1(e$1, __x$2);
    
  }
}

function convert(e) {
  return go$1(e, mkHalt);
}

var ANF = {
  mkHalt: mkHalt,
  letStar: letStar,
  convert: convert
};

function compute(t) {
  switch (t.TAG) {
    case "Halt" :
        var x = t._0;
        switch (x.TAG) {
          case "AtomVar" :
              return Belt_SetString.fromArray([x._0]);
          case "AtomInt" :
          case "AtomGlob" :
              return ;
          
        }
    case "Fun" :
        var f = t._0;
        var fvE = compute(t._2);
        var fvE$p = compute(t._3);
        var bound = Belt_SetString.fromArray([f].concat(Core__List.toArray(t._1)));
        return Belt_SetString.union(Belt_SetString.diff(fvE, bound), Belt_SetString.diff(fvE$p, Belt_SetString.fromArray([f])));
    case "Join" :
        var p = t._1;
        var j = t._0;
        if (p !== undefined) {
          var fvE$1 = compute(t._2);
          var fvE$p$1 = compute(t._3);
          var bound$1 = Belt_SetString.fromArray([
                j,
                p
              ]);
          return Belt_SetString.union(Belt_SetString.diff(fvE$1, bound$1), Belt_SetString.diff(fvE$p$1, bound$1));
        }
        var fvE$2 = compute(t._2);
        var fvE$p$2 = compute(t._3);
        var bound$2 = Belt_SetString.fromArray([j]);
        return Belt_SetString.union(Belt_SetString.diff(fvE$2, bound$2), Belt_SetString.diff(fvE$p$2, bound$2));
    case "Jump" :
        var match = t._1;
        var j$1 = t._0;
        if (match === undefined) {
          return Belt_SetString.fromArray([j$1]);
        }
        switch (match.TAG) {
          case "AtomVar" :
              return Belt_SetString.fromArray([
                          j$1,
                          match._0
                        ]);
          case "AtomInt" :
          case "AtomGlob" :
              return Belt_SetString.fromArray([j$1]);
          
        }
    case "App" :
        var atomVars = Core__List.toArray(Core__List.map(t._2, (function (atom) {
                      switch (atom.TAG) {
                        case "AtomVar" :
                            return [atom._0];
                        case "AtomInt" :
                        case "AtomGlob" :
                            return [];
                        
                      }
                    }))).flat();
        var fvE$3 = compute(t._3);
        return Belt_SetString.union(Belt_SetString.fromArray([t._1].concat(atomVars)), Belt_SetString.diff(fvE$3, Belt_SetString.fromArray([t._0])));
    case "Bop" :
        var atomVars$1 = [
              t._2,
              t._3
            ].map(function (atom) {
                switch (atom.TAG) {
                  case "AtomVar" :
                      return [atom._0];
                  case "AtomInt" :
                  case "AtomGlob" :
                      return [];
                  
                }
              }).flat();
        var fvE$4 = compute(t._4);
        return Belt_SetString.union(Belt_SetString.fromArray(atomVars$1), Belt_SetString.diff(fvE$4, Belt_SetString.fromArray([t._0])));
    case "If" :
        var x$1 = t._0;
        switch (x$1.TAG) {
          case "AtomVar" :
              return Belt_SetString.union(Belt_SetString.fromArray([x$1._0]), Belt_SetString.union(compute(t._1), compute(t._2)));
          case "AtomInt" :
          case "AtomGlob" :
              break;
          
        }
        return Belt_SetString.union(compute(t._1), compute(t._2));
    case "Tuple" :
        var atomVars$2 = Core__List.toArray(Core__List.map(t._1, (function (atom) {
                      switch (atom.TAG) {
                        case "AtomVar" :
                            return [atom._0];
                        case "AtomInt" :
                        case "AtomGlob" :
                            return [];
                        
                      }
                    }))).flat();
        var fvE$5 = compute(t._2);
        return Belt_SetString.union(Belt_SetString.fromArray(atomVars$2), Belt_SetString.diff(fvE$5, Belt_SetString.fromArray([t._0])));
    case "Proj" :
        var fvE$6 = compute(t._3);
        return Belt_SetString.union(Belt_SetString.fromArray([t._1]), Belt_SetString.diff(fvE$6, Belt_SetString.fromArray([t._0])));
    
  }
}

var FreeVars = {
  compute: compute
};

function go$2(t) {
  switch (t.TAG) {
    case "Fun" :
        var e = t._2;
        var f = t._0;
        var env = fresh("env");
        var fvs = Core__List.fromArray(Belt_SetString.toArray(compute(e)));
        var addProjections = function (body, fvList, index) {
          if (fvList) {
            return {
                    TAG: "Proj",
                    _0: fvList.hd,
                    _1: env,
                    _2: index,
                    _3: addProjections(body, fvList.tl, index + 1 | 0)
                  };
          } else {
            return body;
          }
        };
        var transformedBody = addProjections(go$2(e), fvs, 1);
        var vs = Core__List.map(fvs, (function (x) {
                return {
                        TAG: "AtomVar",
                        _0: x
                      };
              }));
        var closureTuple_1 = {
          hd: {
            TAG: "AtomGlob",
            _0: f
          },
          tl: vs
        };
        var closureTuple_2 = go$2(t._3);
        var closureTuple = {
          TAG: "Tuple",
          _0: f,
          _1: closureTuple_1,
          _2: closureTuple_2
        };
        return {
                TAG: "Fun",
                _0: f,
                _1: {
                  hd: env,
                  tl: t._1
                },
                _2: transformedBody,
                _3: closureTuple
              };
    case "Join" :
        return {
                TAG: "Join",
                _0: t._0,
                _1: t._1,
                _2: go$2(t._2),
                _3: go$2(t._3)
              };
    case "Halt" :
    case "Jump" :
        return t;
    case "App" :
        var f$1 = t._1;
        var ptr = fresh("f");
        return {
                TAG: "Proj",
                _0: ptr,
                _1: f$1,
                _2: 0,
                _3: {
                  TAG: "App",
                  _0: t._0,
                  _1: ptr,
                  _2: {
                    hd: {
                      TAG: "AtomVar",
                      _0: f$1
                    },
                    tl: t._2
                  },
                  _3: go$2(t._3)
                }
              };
    case "Bop" :
        return {
                TAG: "Bop",
                _0: t._0,
                _1: t._1,
                _2: t._2,
                _3: t._3,
                _4: go$2(t._4)
              };
    case "If" :
        return {
                TAG: "If",
                _0: t._0,
                _1: go$2(t._1),
                _2: go$2(t._2)
              };
    case "Tuple" :
        return {
                TAG: "Tuple",
                _0: t._0,
                _1: t._1,
                _2: go$2(t._2)
              };
    case "Proj" :
        return {
                TAG: "Proj",
                _0: t._0,
                _1: t._1,
                _2: t._2,
                _3: go$2(t._3)
              };
    
  }
}

var ClosureConversion = {
  convert: go$2
};

function collectBindings(t) {
  switch (t.TAG) {
    case "Fun" :
        var match = collectBindings(t._2);
        var match$1 = collectBindings(t._3);
        var funBinding_0 = t._0;
        var funBinding_1 = t._1;
        var funBinding_2 = match[1];
        var funBinding = {
          TAG: "FunBinding",
          _0: funBinding_0,
          _1: funBinding_1,
          _2: funBinding_2
        };
        return [
                {
                  hd: funBinding,
                  tl: Core__List.concat(match[0], match$1[0])
                },
                match$1[1]
              ];
    case "Join" :
        var match$2 = collectBindings(t._2);
        var match$3 = collectBindings(t._3);
        return [
                Core__List.concat(match$2[0], match$3[0]),
                {
                  TAG: "Join",
                  _0: t._0,
                  _1: t._1,
                  _2: match$2[1],
                  _3: match$3[1]
                }
              ];
    case "Halt" :
    case "Jump" :
        return [
                /* [] */0,
                t
              ];
    case "App" :
        var match$4 = collectBindings(t._3);
        return [
                match$4[0],
                {
                  TAG: "App",
                  _0: t._0,
                  _1: t._1,
                  _2: t._2,
                  _3: match$4[1]
                }
              ];
    case "Bop" :
        var r = t._0;
        var match$5 = collectBindings(t._4);
        var varBinding_1 = {
          TAG: "AtomVar",
          _0: r
        };
        var varBinding = {
          TAG: "VarBinding",
          _0: r,
          _1: varBinding_1
        };
        return [
                {
                  hd: varBinding,
                  tl: match$5[0]
                },
                {
                  TAG: "Bop",
                  _0: r,
                  _1: t._1,
                  _2: t._2,
                  _3: t._3,
                  _4: match$5[1]
                }
              ];
    case "If" :
        var match$6 = collectBindings(t._1);
        var match$7 = collectBindings(t._2);
        return [
                Core__List.concat(match$6[0], match$7[0]),
                {
                  TAG: "If",
                  _0: t._0,
                  _1: match$6[1],
                  _2: match$7[1]
                }
              ];
    case "Tuple" :
        var match$8 = collectBindings(t._2);
        var tupleBinding_0 = t._0;
        var tupleBinding_1 = t._1;
        var tupleBinding = {
          TAG: "TupleBinding",
          _0: tupleBinding_0,
          _1: tupleBinding_1
        };
        return [
                {
                  hd: tupleBinding,
                  tl: match$8[0]
                },
                match$8[1]
              ];
    case "Proj" :
        var match$9 = collectBindings(t._3);
        var varBinding_0 = t._0;
        var varBinding_1$1 = {
          TAG: "AtomVar",
          _0: t._1
        };
        var varBinding$1 = {
          TAG: "VarBinding",
          _0: varBinding_0,
          _1: varBinding_1$1
        };
        return [
                {
                  hd: varBinding$1,
                  tl: match$9[0]
                },
                match$9[1]
              ];
    
  }
}

function reconstructWithBindings(bindings, body) {
  if (!bindings) {
    return body;
  }
  var match = bindings.hd;
  switch (match.TAG) {
    case "FunBinding" :
        var restBody = reconstructWithBindings(bindings.tl, body);
        return {
                TAG: "Fun",
                _0: match._0,
                _1: match._1,
                _2: match._2,
                _3: restBody
              };
    case "VarBinding" :
        var restBody$1 = reconstructWithBindings(bindings.tl, body);
        switch (match._1.TAG) {
          case "AtomInt" :
          case "AtomVar" :
          case "AtomGlob" :
              return restBody$1;
          
        }
    case "TupleBinding" :
        var restBody$2 = reconstructWithBindings(bindings.tl, body);
        return {
                TAG: "Tuple",
                _0: match._0,
                _1: match._1,
                _2: restBody$2
              };
    
  }
}

function hoist(t) {
  var match = collectBindings(t);
  var match$1 = Core__List.partition(match[0], (function (binding) {
          switch (binding.TAG) {
            case "FunBinding" :
                return true;
            case "VarBinding" :
            case "TupleBinding" :
                return false;
            
          }
        }));
  var orderedBindings = Core__List.concat(match$1[0], match$1[1]);
  return reconstructWithBindings(orderedBindings, match[1]);
}

var Hoisting = {
  collectBindings: collectBindings,
  reconstructWithBindings: reconstructWithBindings,
  hoist: hoist
};

function printAtom(atom) {
  switch (atom.TAG) {
    case "AtomInt" :
        return atom._0.toString();
    case "AtomVar" :
        return atom._0;
    case "AtomGlob" :
        return "@" + atom._0;
    
  }
}

function printANF(t) {
  switch (t.TAG) {
    case "Halt" :
        return "halt " + printAtom(t._0);
    case "Fun" :
        var params = Core__List.toArray(t._1).join(", ");
        return "fun " + t._0 + "(" + params + ") =\n  " + printANF(t._2) + "\nin\n" + printANF(t._3);
    case "Join" :
        var p = t._1;
        var j = t._0;
        if (p !== undefined) {
          return "join " + j + "(" + p + ") =\n  " + printANF(t._2) + "\nin\n" + printANF(t._3);
        } else {
          return "join " + j + " =\n  " + printANF(t._2) + "\nin\n" + printANF(t._3);
        }
    case "Jump" :
        var atom = t._1;
        var j$1 = t._0;
        if (atom !== undefined) {
          return "jump " + j$1 + "(" + printAtom(atom) + ")";
        } else {
          return "jump " + j$1;
        }
    case "App" :
        var args = Core__List.toArray(Core__List.map(t._2, printAtom)).join(", ");
        return "let " + t._0 + " = " + t._1 + "(" + args + ") in\n" + printANF(t._3);
    case "Bop" :
        var r = t._0;
        if (t._1 === "Plus") {
          return "let " + r + " = " + printAtom(t._2) + " + " + printAtom(t._3) + " in\n" + printANF(t._4);
        } else {
          return "let " + r + " = " + printAtom(t._2) + " - " + printAtom(t._3) + " in\n" + printANF(t._4);
        }
    case "If" :
        return "if " + printAtom(t._0) + " then\n  " + printANF(t._1) + "\nelse\n  " + printANF(t._2);
    case "Tuple" :
        var values = Core__List.toArray(Core__List.map(t._1, printAtom)).join(", ");
        return "let " + t._0 + " = (" + values + ") in\n" + printANF(t._2);
    case "Proj" :
        return "let " + t._0 + " = " + t._1 + "." + t._2.toString() + " in\n" + printANF(t._3);
    
  }
}

function printLam(t) {
  switch (t.TAG) {
    case "Int" :
        return t._0.toString();
    case "Var" :
        return t._0;
    case "Lam" :
        return "(λ" + t._0 + ". " + printLam(t._1) + ")";
    case "App" :
        return "(" + printLam(t._0) + " " + printLam(t._1) + ")";
    case "Bop" :
        if (t._0 === "Plus") {
          return "(" + printLam(t._1) + " + " + printLam(t._2) + ")";
        } else {
          return "(" + printLam(t._1) + " - " + printLam(t._2) + ")";
        }
    case "If" :
        return "if " + printLam(t._0) + " then " + printLam(t._1) + " else " + printLam(t._2);
    
  }
}

var Print = {
  printAtom: printAtom,
  printANF: printANF,
  printLam: printLam
};

function lowerPhase1(anf) {
  var instructions = {
    contents: /* [] */0
  };
  var go = function (_t) {
    while(true) {
      var t = _t;
      switch (t.TAG) {
        case "Halt" :
            var n = t._0;
            switch (n.TAG) {
              case "AtomInt" :
                  instructions.contents = {
                    hd: "ret i64 " + n._0.toString(),
                    tl: instructions.contents
                  };
                  return ;
              case "AtomVar" :
                  instructions.contents = {
                    hd: "ret i64 %" + n._0,
                    tl: instructions.contents
                  };
                  return ;
              case "AtomGlob" :
                  return PervasivesU.failwith("Phase 1: Unsupported ANF construct");
              
            }
        case "Bop" :
            var r = t._0;
            if (t._1 === "Plus") {
              var x = t._2;
              switch (x.TAG) {
                case "AtomInt" :
                    var y = t._3;
                    var x$1 = x._0;
                    switch (y.TAG) {
                      case "AtomInt" :
                          instructions.contents = {
                            hd: "%" + r + " = add i64 " + x$1.toString() + ", " + y._0.toString(),
                            tl: instructions.contents
                          };
                          _t = t._4;
                          continue ;
                      case "AtomVar" :
                          instructions.contents = {
                            hd: "%" + r + " = add i64 " + x$1.toString() + ", %" + y._0,
                            tl: instructions.contents
                          };
                          _t = t._4;
                          continue ;
                      case "AtomGlob" :
                          return PervasivesU.failwith("Phase 1: Unsupported ANF construct");
                      
                    }
                case "AtomVar" :
                    var y$1 = t._3;
                    var x$2 = x._0;
                    switch (y$1.TAG) {
                      case "AtomInt" :
                          instructions.contents = {
                            hd: "%" + r + " = add i64 %" + x$2 + ", " + y$1._0.toString(),
                            tl: instructions.contents
                          };
                          _t = t._4;
                          continue ;
                      case "AtomVar" :
                          instructions.contents = {
                            hd: "%" + r + " = add i64 %" + x$2 + ", %" + y$1._0,
                            tl: instructions.contents
                          };
                          _t = t._4;
                          continue ;
                      case "AtomGlob" :
                          return PervasivesU.failwith("Phase 1: Unsupported ANF construct");
                      
                    }
                case "AtomGlob" :
                    return PervasivesU.failwith("Phase 1: Unsupported ANF construct");
                
              }
            } else {
              var x$3 = t._2;
              switch (x$3.TAG) {
                case "AtomInt" :
                    var y$2 = t._3;
                    var x$4 = x$3._0;
                    switch (y$2.TAG) {
                      case "AtomInt" :
                          instructions.contents = {
                            hd: "%" + r + " = sub i64 " + x$4.toString() + ", " + y$2._0.toString(),
                            tl: instructions.contents
                          };
                          _t = t._4;
                          continue ;
                      case "AtomVar" :
                          instructions.contents = {
                            hd: "%" + r + " = sub i64 " + x$4.toString() + ", %" + y$2._0,
                            tl: instructions.contents
                          };
                          _t = t._4;
                          continue ;
                      case "AtomGlob" :
                          return PervasivesU.failwith("Phase 1: Unsupported ANF construct");
                      
                    }
                case "AtomVar" :
                    var y$3 = t._3;
                    var x$5 = x$3._0;
                    switch (y$3.TAG) {
                      case "AtomInt" :
                          instructions.contents = {
                            hd: "%" + r + " = sub i64 %" + x$5 + ", " + y$3._0.toString(),
                            tl: instructions.contents
                          };
                          _t = t._4;
                          continue ;
                      case "AtomVar" :
                          instructions.contents = {
                            hd: "%" + r + " = sub i64 %" + x$5 + ", %" + y$3._0,
                            tl: instructions.contents
                          };
                          _t = t._4;
                          continue ;
                      case "AtomGlob" :
                          return PervasivesU.failwith("Phase 1: Unsupported ANF construct");
                      
                    }
                case "AtomGlob" :
                    return PervasivesU.failwith("Phase 1: Unsupported ANF construct");
                
              }
            }
        default:
          return PervasivesU.failwith("Phase 1: Unsupported ANF construct");
      }
    };
  };
  go(anf);
  var body = Core__List.toArray(Core__List.reverse(instructions.contents)).join("\n  ");
  return "define i64 @main() {\nentry:\n  " + body + "\n}";
}

function atomToString(atom) {
  switch (atom.TAG) {
    case "AtomInt" :
        return atom._0.toString();
    case "AtomVar" :
        return "%" + atom._0;
    case "AtomGlob" :
        return "@" + atom._0;
    
  }
}

function lowerPhase2(anf) {
  var functions = {
    contents: /* [] */0
  };
  var mainInstructions = {
    contents: /* [] */0
  };
  var extractFunctions = function (_t) {
    while(true) {
      var t = _t;
      switch (t.TAG) {
        case "Halt" :
            var x = t._0;
            switch (x.TAG) {
              case "AtomInt" :
                  mainInstructions.contents = {
                    hd: "ret i64 " + x._0.toString(),
                    tl: mainInstructions.contents
                  };
                  return ;
              case "AtomVar" :
                  var x$1 = x._0;
                  var isFunctionName = Core__List.some(functions.contents, (function(x$1){
                      return function (funcDef) {
                        return funcDef.includes("@" + x$1 + "(");
                      }
                      }(x$1)));
                  if (isFunctionName) {
                    return PervasivesU.failwith("Phase 2: Function references not yet supported: " + x$1);
                  } else {
                    mainInstructions.contents = {
                      hd: "ret i64 %" + x$1,
                      tl: mainInstructions.contents
                    };
                    return ;
                  }
              case "AtomGlob" :
                  return PervasivesU.failwith("Phase 2: Unsupported ANF construct");
              
            }
        case "Fun" :
            var paramList = Core__List.toArray(Core__List.map(t._1, (function (p) {
                          return "i64 %" + p;
                        }))).join(", ");
            var bodyInstructions = {
              contents: /* [] */0
            };
            var generateBody = (function(bodyInstructions){
            return function generateBody(_bodyTerm) {
              while(true) {
                var bodyTerm = _bodyTerm;
                switch (bodyTerm.TAG) {
                  case "Halt" :
                      var n = bodyTerm._0;
                      switch (n.TAG) {
                        case "AtomInt" :
                            bodyInstructions.contents = {
                              hd: "ret i64 " + n._0.toString(),
                              tl: bodyInstructions.contents
                            };
                            return ;
                        case "AtomVar" :
                            bodyInstructions.contents = {
                              hd: "ret i64 %" + n._0,
                              tl: bodyInstructions.contents
                            };
                            return ;
                        case "AtomGlob" :
                            return PervasivesU.failwith("Phase 2: Unsupported construct in function body");
                        
                      }
                  case "Bop" :
                      var r = bodyTerm._0;
                      if (bodyTerm._1 === "Plus") {
                        bodyInstructions.contents = {
                          hd: "%" + r + " = add i64 " + atomToString(bodyTerm._2) + ", " + atomToString(bodyTerm._3),
                          tl: bodyInstructions.contents
                        };
                        _bodyTerm = bodyTerm._4;
                        continue ;
                      }
                      bodyInstructions.contents = {
                        hd: "%" + r + " = sub i64 " + atomToString(bodyTerm._2) + ", " + atomToString(bodyTerm._3),
                        tl: bodyInstructions.contents
                      };
                      _bodyTerm = bodyTerm._4;
                      continue ;
                  default:
                    return PervasivesU.failwith("Phase 2: Unsupported construct in function body");
                }
              };
            }
            }(bodyInstructions));
            generateBody(t._2);
            var bodyStr = Core__List.toArray(Core__List.reverse(bodyInstructions.contents)).join("\n  ");
            var funcDef = "define i64 @" + t._0 + "(" + paramList + ") {\nentry:\n  " + bodyStr + "\n}";
            functions.contents = {
              hd: funcDef,
              tl: functions.contents
            };
            _t = t._3;
            continue ;
        case "App" :
            var argList = Core__List.toArray(Core__List.map(t._2, (function (atom) {
                          switch (atom.TAG) {
                            case "AtomInt" :
                                return "i64 " + atom._0.toString();
                            case "AtomVar" :
                                return "i64 %" + atom._0;
                            case "AtomGlob" :
                                return "i64 @" + atom._0;
                            
                          }
                        }))).join(", ");
            mainInstructions.contents = {
              hd: "%" + t._0 + " = call i64 @" + t._1 + "(" + argList + ")",
              tl: mainInstructions.contents
            };
            _t = t._3;
            continue ;
        case "Bop" :
            var r = t._0;
            if (t._1 === "Plus") {
              mainInstructions.contents = {
                hd: "%" + r + " = add i64 " + atomToString(t._2) + ", " + atomToString(t._3),
                tl: mainInstructions.contents
              };
              _t = t._4;
              continue ;
            }
            mainInstructions.contents = {
              hd: "%" + r + " = sub i64 " + atomToString(t._2) + ", " + atomToString(t._3),
              tl: mainInstructions.contents
            };
            _t = t._4;
            continue ;
        default:
          return PervasivesU.failwith("Phase 2: Unsupported ANF construct");
      }
    };
  };
  extractFunctions(anf);
  var functionsStr = Core__List.toArray(Core__List.reverse(functions.contents)).join("\n\n");
  var mainBody = Core__List.toArray(Core__List.reverse(mainInstructions.contents)).join("\n  ");
  var mainFunc = "define i64 @main() {\nentry:\n  " + mainBody + "\n}";
  if (Core__List.length(functions.contents) > 0) {
    return functionsStr + "\n\n" + mainFunc;
  } else {
    return mainFunc;
  }
}

var LLVMLowering = {
  lowerPhase1: lowerPhase1,
  atomToString: atomToString,
  lowerPhase2: lowerPhase2
};

function compile(term) {
  return hoist(go$2(go$1(rename(term), mkHalt)));
}

var Compiler = {
  compile: compile
};

var testLambda = {
  TAG: "Lam",
  _0: "x",
  _1: {
    TAG: "Var",
    _0: "x"
  }
};

var testApp = {
  TAG: "App",
  _0: {
    TAG: "Lam",
    _0: "x",
    _1: {
      TAG: "Var",
      _0: "x"
    }
  },
  _1: {
    TAG: "Int",
    _0: 42
  }
};

var testBop = {
  TAG: "Bop",
  _0: "Plus",
  _1: {
    TAG: "Int",
    _0: 3
  },
  _2: {
    TAG: "Int",
    _0: 4
  }
};

var testIf = {
  TAG: "If",
  _0: {
    TAG: "Int",
    _0: 1
  },
  _1: {
    TAG: "Int",
    _0: 2
  },
  _2: {
    TAG: "Int",
    _0: 3
  }
};

var testNested = {
  TAG: "Lam",
  _0: "x",
  _1: {
    TAG: "App",
    _0: {
      TAG: "Lam",
      _0: "y",
      _1: {
        TAG: "App",
        _0: {
          TAG: "Lam",
          _0: "z",
          _1: {
            TAG: "Bop",
            _0: "Plus",
            _1: {
              TAG: "Var",
              _0: "x"
            },
            _2: {
              TAG: "Bop",
              _0: "Plus",
              _1: {
                TAG: "Var",
                _0: "y"
              },
              _2: {
                TAG: "Var",
                _0: "z"
              }
            }
          }
        },
        _1: {
          TAG: "Int",
          _0: 3
        }
      }
    },
    _1: {
      TAG: "Int",
      _0: 2
    }
  }
};

var testCurried = {
  TAG: "Lam",
  _0: "x",
  _1: {
    TAG: "Lam",
    _0: "y",
    _1: {
      TAG: "Bop",
      _0: "Plus",
      _1: {
        TAG: "Var",
        _0: "x"
      },
      _2: {
        TAG: "Var",
        _0: "y"
      }
    }
  }
};

var testComplexFreeVars = {
  TAG: "App",
  _0: {
    TAG: "Lam",
    _0: "a",
    _1: {
      TAG: "App",
      _0: {
        TAG: "Lam",
        _0: "b",
        _1: {
          TAG: "App",
          _0: {
            TAG: "Lam",
            _0: "c",
            _1: {
              TAG: "Bop",
              _0: "Plus",
              _1: {
                TAG: "Var",
                _0: "a"
              },
              _2: {
                TAG: "Bop",
                _0: "Plus",
                _1: {
                  TAG: "Var",
                  _0: "b"
                },
                _2: {
                  TAG: "Var",
                  _0: "c"
                }
              }
            }
          },
          _1: {
            TAG: "Bop",
            _0: "Plus",
            _1: {
              TAG: "Var",
              _0: "a"
            },
            _2: {
              TAG: "Var",
              _0: "b"
            }
          }
        }
      },
      _1: {
        TAG: "Bop",
        _0: "Plus",
        _1: {
          TAG: "Var",
          _0: "a"
        },
        _2: {
          TAG: "Int",
          _0: 1
        }
      }
    }
  },
  _1: {
    TAG: "Int",
    _0: 10
  }
};

var testConditionalNested = {
  TAG: "If",
  _0: {
    TAG: "Int",
    _0: 1
  },
  _1: {
    TAG: "Lam",
    _0: "x",
    _1: {
      TAG: "Bop",
      _0: "Plus",
      _1: {
        TAG: "Var",
        _0: "x"
      },
      _2: {
        TAG: "Int",
        _0: 1
      }
    }
  },
  _2: {
    TAG: "Lam",
    _0: "y",
    _1: {
      TAG: "Bop",
      _0: "Minus",
      _1: {
        TAG: "Var",
        _0: "y"
      },
      _2: {
        TAG: "Int",
        _0: 1
      }
    }
  }
};

console.log("=== Original Lambda Terms ===");

console.log("Identity function:", printLam(testLambda));

console.log("Application:", printLam(testApp));

console.log("Binary operation:", printLam(testBop));

console.log("If expression:", printLam(testIf));

console.log("\n=== After Alpha Renaming ===");

var renamedLambda = rename(testLambda);

var renamedApp = rename(testApp);

var renamedBop = rename(testBop);

var renamedIf = rename(testIf);

console.log("Identity function:", printLam(renamedLambda));

console.log("Application:", printLam(renamedApp));

console.log("Binary operation:", printLam(renamedBop));

console.log("If expression:", printLam(renamedIf));

console.log("\n=== After ANF Conversion ===");

var anfLambda = go$1(renamedLambda, mkHalt);

var anfApp = go$1(renamedApp, mkHalt);

var anfBop = go$1(renamedBop, mkHalt);

var anfIf = go$1(renamedIf, mkHalt);

console.log("Identity function:", printANF(anfLambda));

console.log("Application:", printANF(anfApp));

console.log("Binary operation:", printANF(anfBop));

console.log("If expression:", printANF(anfIf));

console.log("\n=== After Closure Conversion ===");

var closureLambda = go$2(anfLambda);

var closureApp = go$2(anfApp);

var closureBop = go$2(anfBop);

var closureIf = go$2(anfIf);

console.log("Identity function:", printANF(closureLambda));

console.log("Application:", printANF(closureApp));

console.log("Binary operation:", printANF(closureBop));

console.log("If expression:", printANF(closureIf));

console.log("\n=== After Hoisting (Correct Order) ===");

var hoistedLambda = hoist(closureLambda);

var hoistedApp = hoist(closureApp);

var hoistedBop = hoist(closureBop);

var hoistedIf = hoist(closureIf);

console.log("Identity function:", printANF(hoistedLambda));

console.log("Application:", printANF(hoistedApp));

console.log("Binary operation:", printANF(hoistedBop));

console.log("If expression:", printANF(hoistedIf));

console.log("\n=== Complete Compilation Pipeline ===");

var compiledLambda = compile(testLambda);

var compiledApp = compile(testApp);

var compiledBop = compile(testBop);

var compiledIf = compile(testIf);

console.log("Identity function:", printANF(compiledLambda));

console.log("Application:", printANF(compiledApp));

console.log("Binary operation:", printANF(compiledBop));

console.log("If expression:", printANF(compiledIf));

console.log("\n=== Complex Test Cases ===");

console.log("--- Original Complex Lambda Terms ---");

console.log("Nested functions:", printLam(testNested));

console.log("Curried function:", printLam(testCurried));

console.log("Complex free vars:", printLam(testComplexFreeVars));

console.log("Conditional nested:", printLam(testConditionalNested));

console.log("\n--- After Alpha Renaming ---");

var renamedNested = rename(testNested);

var renamedCurried = rename(testCurried);

var renamedComplexFreeVars = rename(testComplexFreeVars);

var renamedConditionalNested = rename(testConditionalNested);

console.log("Nested functions:", printLam(renamedNested));

console.log("Curried function:", printLam(renamedCurried));

console.log("Complex free vars:", printLam(renamedComplexFreeVars));

console.log("Conditional nested:", printLam(renamedConditionalNested));

console.log("\n--- After ANF Conversion ---");

var anfNested = go$1(renamedNested, mkHalt);

var anfCurried = go$1(renamedCurried, mkHalt);

var anfComplexFreeVars = go$1(renamedComplexFreeVars, mkHalt);

var anfConditionalNested = go$1(renamedConditionalNested, mkHalt);

console.log("Nested functions:", printANF(anfNested));

console.log("Curried function:", printANF(anfCurried));

console.log("Complex free vars:", printANF(anfComplexFreeVars));

console.log("Conditional nested:", printANF(anfConditionalNested));

console.log("\n--- After Closure Conversion (Correct Order) ---");

var closureNested = go$2(anfNested);

var closureCurried = go$2(anfCurried);

var closureComplexFreeVars = go$2(anfComplexFreeVars);

var closureConditionalNested = go$2(anfConditionalNested);

console.log("Nested functions:", printANF(closureNested));

console.log("Curried function:", printANF(closureCurried));

console.log("Complex free vars:", printANF(closureComplexFreeVars));

console.log("Conditional nested:", printANF(closureConditionalNested));

console.log("\n--- After Hoisting (Correct Order) ---");

var hoistedNested = hoist(closureNested);

var hoistedCurried = hoist(closureCurried);

var hoistedComplexFreeVars = hoist(closureComplexFreeVars);

var hoistedConditionalNested = hoist(closureConditionalNested);

console.log("Nested functions:", printANF(hoistedNested));

console.log("Curried function:", printANF(hoistedCurried));

console.log("Complex free vars:", printANF(hoistedComplexFreeVars));

console.log("Conditional nested:", printANF(hoistedConditionalNested));

console.log("\n--- Complete Compilation Pipeline (Correct Order) ---");

var finalNested = compile(testNested);

var finalCurried = compile(testCurried);

var finalComplexFreeVars = compile(testComplexFreeVars);

var finalConditionalNested = compile(testConditionalNested);

console.log("Nested functions:", printANF(finalNested));

console.log("Curried function:", printANF(finalCurried));

console.log("Complex free vars:", printANF(finalComplexFreeVars));

console.log("Conditional nested:", printANF(finalConditionalNested));

console.log("\n=== LLVMlite Lowering Phase 1 Tests ===");

var testSimpleInt = {
  TAG: "Halt",
  _0: {
    TAG: "AtomInt",
    _0: 42
  }
};

console.log("--- Test 1: Simple integer ---");

console.log("ANF:", printANF(testSimpleInt));

console.log("LLVM IR:", lowerPhase1(testSimpleInt));

var testAddInts = {
  TAG: "Bop",
  _0: "r",
  _1: "Plus",
  _2: {
    TAG: "AtomInt",
    _0: 3
  },
  _3: {
    TAG: "AtomInt",
    _0: 4
  },
  _4: {
    TAG: "Halt",
    _0: {
      TAG: "AtomVar",
      _0: "r"
    }
  }
};

console.log("\n--- Test 2: Addition with integers ---");

console.log("ANF:", printANF(testAddInts));

console.log("LLVM IR:", lowerPhase1(testAddInts));

var testSubInts = {
  TAG: "Bop",
  _0: "s",
  _1: "Minus",
  _2: {
    TAG: "AtomInt",
    _0: 10
  },
  _3: {
    TAG: "AtomInt",
    _0: 3
  },
  _4: {
    TAG: "Halt",
    _0: {
      TAG: "AtomVar",
      _0: "s"
    }
  }
};

console.log("\n--- Test 3: Subtraction with integers ---");

console.log("ANF:", printANF(testSubInts));

console.log("LLVM IR:", lowerPhase1(testSubInts));

console.log("\n--- Test 4: Existing binary operation test ---");

console.log("ANF:", printANF(hoistedBop));

try {
  console.log("LLVM IR:", lowerPhase1(hoistedBop));
}
catch (raw_msg){
  var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
  if (msg.RE_EXN_ID === "Failure") {
    console.log("Expected failure:", msg._1);
  } else {
    console.log("Unexpected error");
  }
}

console.log("\n=== LLVMlite Lowering Phase 2 Tests ===");

var testSimpleFunc = {
  TAG: "Fun",
  _0: "identity",
  _1: {
    hd: "x",
    tl: /* [] */0
  },
  _2: {
    TAG: "Halt",
    _0: {
      TAG: "AtomVar",
      _0: "x"
    }
  },
  _3: {
    TAG: "Halt",
    _0: {
      TAG: "AtomVar",
      _0: "identity"
    }
  }
};

console.log("--- Test 5: Simple function definition ---");

console.log("ANF:", printANF(testSimpleFunc));

console.log("LLVM IR:", lowerPhase2(testSimpleFunc));

var testFuncWithArith = {
  TAG: "Fun",
  _0: "addOne",
  _1: {
    hd: "x",
    tl: /* [] */0
  },
  _2: {
    TAG: "Bop",
    _0: "r",
    _1: "Plus",
    _2: {
      TAG: "AtomVar",
      _0: "x"
    },
    _3: {
      TAG: "AtomInt",
      _0: 1
    },
    _4: {
      TAG: "Halt",
      _0: {
        TAG: "AtomVar",
        _0: "r"
      }
    }
  },
  _3: {
    TAG: "Halt",
    _0: {
      TAG: "AtomVar",
      _0: "addOne"
    }
  }
};

console.log("\n--- Test 6: Function with arithmetic ---");

console.log("ANF:", printANF(testFuncWithArith));

console.log("LLVM IR:", lowerPhase2(testFuncWithArith));

var testFuncCall = {
  TAG: "Fun",
  _0: "double",
  _1: {
    hd: "x",
    tl: /* [] */0
  },
  _2: {
    TAG: "Bop",
    _0: "r",
    _1: "Plus",
    _2: {
      TAG: "AtomVar",
      _0: "x"
    },
    _3: {
      TAG: "AtomVar",
      _0: "x"
    },
    _4: {
      TAG: "Halt",
      _0: {
        TAG: "AtomVar",
        _0: "r"
      }
    }
  },
  _3: {
    TAG: "App",
    _0: "result",
    _1: "double",
    _2: {
      hd: {
        TAG: "AtomInt",
        _0: 21
      },
      tl: /* [] */0
    },
    _3: {
      TAG: "Halt",
      _0: {
        TAG: "AtomVar",
        _0: "result"
      }
    }
  }
};

console.log("\n--- Test 7: Function call ---");

console.log("ANF:", printANF(testFuncCall));

console.log("LLVM IR:", lowerPhase2(testFuncCall));

console.log("\n--- Test 8: ANF identity function test ---");

console.log("ANF:", printANF(anfLambda));

try {
  console.log("LLVM IR:", lowerPhase2(anfLambda));
}
catch (raw_msg$1){
  var msg$1 = Caml_js_exceptions.internalToOCamlException(raw_msg$1);
  if (msg$1.RE_EXN_ID === "Failure") {
    console.log("Expected failure (complex constructs):", msg$1._1);
  } else {
    console.log("Unexpected error");
  }
}

export {
  Lam ,
  ANF ,
  FreeVars ,
  ClosureConversion ,
  Hoisting ,
  Print ,
  LLVMLowering ,
  Compiler ,
  testLambda ,
  testApp ,
  testBop ,
  testIf ,
  testNested ,
  testCurried ,
  testComplexFreeVars ,
  testConditionalNested ,
  renamedLambda ,
  renamedApp ,
  renamedBop ,
  renamedIf ,
  anfLambda ,
  anfApp ,
  anfBop ,
  anfIf ,
  closureLambda ,
  closureApp ,
  closureBop ,
  closureIf ,
  hoistedLambda ,
  hoistedApp ,
  hoistedBop ,
  hoistedIf ,
  compiledLambda ,
  compiledApp ,
  compiledBop ,
  compiledIf ,
  renamedNested ,
  renamedCurried ,
  renamedComplexFreeVars ,
  renamedConditionalNested ,
  anfNested ,
  anfCurried ,
  anfComplexFreeVars ,
  anfConditionalNested ,
  closureNested ,
  closureCurried ,
  closureComplexFreeVars ,
  closureConditionalNested ,
  hoistedNested ,
  hoistedCurried ,
  hoistedComplexFreeVars ,
  hoistedConditionalNested ,
  finalNested ,
  finalCurried ,
  finalComplexFreeVars ,
  finalConditionalNested ,
  testSimpleInt ,
  testAddInts ,
  testSubInts ,
  testSimpleFunc ,
  testFuncWithArith ,
  testFuncCall ,
}
/* rename Not a pure module */
