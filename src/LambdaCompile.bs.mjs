// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__List from "@rescript/core/src/Core__List.bs.mjs";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";
import * as Belt_MapString from "rescript/lib/es6/belt_MapString.js";
import * as Belt_SetString from "rescript/lib/es6/belt_SetString.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

var NoRuleApplies = /* @__PURE__ */Caml_exceptions.create("LambdaCompile.Lam.NoRuleApplies");

var c = {
  contents: -1
};

function fresh(str) {
  c.contents = c.contents + 1 | 0;
  return str + c.contents.toString();
}

function go(env) {
  return function (t) {
    switch (t.TAG) {
      case "Int" :
          return {
                  TAG: "Int",
                  _0: t._0
                };
      case "Var" :
          var name$p = Belt_MapString.get(env, t._0);
          if (name$p !== undefined) {
            return {
                    TAG: "Var",
                    _0: name$p
                  };
          }
          throw {
                RE_EXN_ID: NoRuleApplies,
                _1: t,
                Error: new Error()
              };
      case "Lam" :
          var name = t._0;
          var name$p$1 = fresh(name);
          var env$p = Belt_MapString.set(env, name, name$p$1);
          return {
                  TAG: "Lam",
                  _0: name$p$1,
                  _1: go(env$p)(t._1)
                };
      case "App" :
          return {
                  TAG: "App",
                  _0: go(env)(t._0),
                  _1: go(env)(t._1)
                };
      case "Bop" :
          return {
                  TAG: "Bop",
                  _0: t._0,
                  _1: go(env)(t._1),
                  _2: go(env)(t._2)
                };
      case "If" :
          return {
                  TAG: "If",
                  _0: go(env)(t._0),
                  _1: go(env)(t._1),
                  _2: go(env)(t._2)
                };
      
    }
  };
}

var rename = go(undefined);

var Lam = {
  NoRuleApplies: NoRuleApplies,
  c: c,
  fresh: fresh,
  rename: rename
};

function mkHalt(v) {
  return {
          TAG: "Halt",
          _0: v
        };
}

function letStar(f, k) {
  return f(k);
}

function go$1(e, k) {
  switch (e.TAG) {
    case "Int" :
        return k({
                    TAG: "AtomInt",
                    _0: e._0
                  });
    case "Var" :
        return k({
                    TAG: "AtomVar",
                    _0: e._0
                  });
    case "Lam" :
        var f = fresh("f");
        var t$p = go$1(e._1, (function (v) {
                return {
                        TAG: "Halt",
                        _0: v
                      };
              }));
        return {
                TAG: "Fun",
                _0: f,
                _1: {
                  hd: e._0,
                  tl: /* [] */0
                },
                _2: t$p,
                _3: k({
                      TAG: "AtomVar",
                      _0: f
                    })
              };
    case "App" :
        var x = e._1;
        var f$1 = e._0;
        var __x = function (fAtom) {
          return (function (__x) {
                      return go$1(x, __x);
                    })(function (xAtom) {
                      switch (fAtom.TAG) {
                        case "AtomVar" :
                            var r = fresh("r");
                            return {
                                    TAG: "App",
                                    _0: r,
                                    _1: fAtom._0,
                                    _2: {
                                      hd: xAtom,
                                      tl: /* [] */0
                                    },
                                    _3: k({
                                          TAG: "AtomVar",
                                          _0: r
                                        })
                                  };
                        case "AtomInt" :
                        case "AtomGlob" :
                            return PervasivesU.failwith("Must apply named value!");
                        
                      }
                    });
        };
        return go$1(f$1, __x);
    case "Bop" :
        var y = e._2;
        var x$1 = e._1;
        var op = e._0;
        var __x$1 = function (xAtom) {
          return (function (__x) {
                      return go$1(y, __x);
                    })(function (yAtom) {
                      var r = fresh("r");
                      return {
                              TAG: "Bop",
                              _0: r,
                              _1: op,
                              _2: xAtom,
                              _3: yAtom,
                              _4: k({
                                    TAG: "AtomVar",
                                    _0: r
                                  })
                            };
                    });
        };
        return go$1(x$1, __x$1);
    case "If" :
        var f$2 = e._2;
        var t = e._1;
        var e$1 = e._0;
        var __x$2 = function (eAtom) {
          var j = fresh("j");
          var p = fresh("p");
          var joinVar_1 = {
            TAG: "AtomVar",
            _0: p
          };
          var joinVar = {
            TAG: "Jump",
            _0: j,
            _1: joinVar_1
          };
          return {
                  TAG: "Join",
                  _0: j,
                  _1: p,
                  _2: k({
                        TAG: "AtomVar",
                        _0: p
                      }),
                  _3: {
                    TAG: "If",
                    _0: eAtom,
                    _1: go$1(t, (function (param) {
                            return joinVar;
                          })),
                    _2: go$1(f$2, (function (param) {
                            return joinVar;
                          }))
                  }
                };
        };
        return go$1(e$1, __x$2);
    
  }
}

function convert(e) {
  return go$1(e, mkHalt);
}

var ANF = {
  mkHalt: mkHalt,
  letStar: letStar,
  convert: convert
};

function compute(t) {
  switch (t.TAG) {
    case "Halt" :
        var x = t._0;
        switch (x.TAG) {
          case "AtomVar" :
              return Belt_SetString.fromArray([x._0]);
          case "AtomInt" :
          case "AtomGlob" :
              return ;
          
        }
    case "Fun" :
        var f = t._0;
        var fvE = compute(t._2);
        var fvE$p = compute(t._3);
        var bound = Belt_SetString.fromArray([f].concat(Core__List.toArray(t._1)));
        return Belt_SetString.union(Belt_SetString.diff(fvE, bound), Belt_SetString.diff(fvE$p, Belt_SetString.fromArray([f])));
    case "Join" :
        var p = t._1;
        var j = t._0;
        if (p !== undefined) {
          var fvE$1 = compute(t._2);
          var fvE$p$1 = compute(t._3);
          var bound$1 = Belt_SetString.fromArray([
                j,
                p
              ]);
          return Belt_SetString.union(Belt_SetString.diff(fvE$1, bound$1), Belt_SetString.diff(fvE$p$1, bound$1));
        }
        var fvE$2 = compute(t._2);
        var fvE$p$2 = compute(t._3);
        var bound$2 = Belt_SetString.fromArray([j]);
        return Belt_SetString.union(Belt_SetString.diff(fvE$2, bound$2), Belt_SetString.diff(fvE$p$2, bound$2));
    case "Jump" :
        var match = t._1;
        var j$1 = t._0;
        if (match === undefined) {
          return Belt_SetString.fromArray([j$1]);
        }
        switch (match.TAG) {
          case "AtomVar" :
              return Belt_SetString.fromArray([
                          j$1,
                          match._0
                        ]);
          case "AtomInt" :
          case "AtomGlob" :
              return Belt_SetString.fromArray([j$1]);
          
        }
    case "App" :
        var atomVars = Core__List.toArray(Core__List.map(t._2, (function (atom) {
                      switch (atom.TAG) {
                        case "AtomVar" :
                            return [atom._0];
                        case "AtomInt" :
                        case "AtomGlob" :
                            return [];
                        
                      }
                    }))).flat();
        var fvE$3 = compute(t._3);
        return Belt_SetString.union(Belt_SetString.fromArray([t._1].concat(atomVars)), Belt_SetString.diff(fvE$3, Belt_SetString.fromArray([t._0])));
    case "Bop" :
        var atomVars$1 = [
              t._2,
              t._3
            ].map(function (atom) {
                switch (atom.TAG) {
                  case "AtomVar" :
                      return [atom._0];
                  case "AtomInt" :
                  case "AtomGlob" :
                      return [];
                  
                }
              }).flat();
        var fvE$4 = compute(t._4);
        return Belt_SetString.union(Belt_SetString.fromArray(atomVars$1), Belt_SetString.diff(fvE$4, Belt_SetString.fromArray([t._0])));
    case "If" :
        var x$1 = t._0;
        switch (x$1.TAG) {
          case "AtomVar" :
              return Belt_SetString.union(Belt_SetString.fromArray([x$1._0]), Belt_SetString.union(compute(t._1), compute(t._2)));
          case "AtomInt" :
          case "AtomGlob" :
              break;
          
        }
        return Belt_SetString.union(compute(t._1), compute(t._2));
    case "Tuple" :
        var atomVars$2 = Core__List.toArray(Core__List.map(t._1, (function (atom) {
                      switch (atom.TAG) {
                        case "AtomVar" :
                            return [atom._0];
                        case "AtomInt" :
                        case "AtomGlob" :
                            return [];
                        
                      }
                    }))).flat();
        var fvE$5 = compute(t._2);
        return Belt_SetString.union(Belt_SetString.fromArray(atomVars$2), Belt_SetString.diff(fvE$5, Belt_SetString.fromArray([t._0])));
    case "Proj" :
        var fvE$6 = compute(t._3);
        return Belt_SetString.union(Belt_SetString.fromArray([t._1]), Belt_SetString.diff(fvE$6, Belt_SetString.fromArray([t._0])));
    
  }
}

var FreeVars = {
  compute: compute
};

function go$2(t) {
  switch (t.TAG) {
    case "Fun" :
        var e = t._2;
        var f = t._0;
        var env = fresh("env");
        var fvs = Core__List.fromArray(Belt_SetString.toArray(compute(e)));
        var addProjections = function (body, fvList, index) {
          if (fvList) {
            return {
                    TAG: "Proj",
                    _0: fvList.hd,
                    _1: env,
                    _2: index,
                    _3: addProjections(body, fvList.tl, index + 1 | 0)
                  };
          } else {
            return body;
          }
        };
        var transformedBody = addProjections(go$2(e), fvs, 1);
        var vs = Core__List.map(fvs, (function (x) {
                return {
                        TAG: "AtomVar",
                        _0: x
                      };
              }));
        var closureTuple_1 = {
          hd: {
            TAG: "AtomGlob",
            _0: f
          },
          tl: vs
        };
        var closureTuple_2 = go$2(t._3);
        var closureTuple = {
          TAG: "Tuple",
          _0: f,
          _1: closureTuple_1,
          _2: closureTuple_2
        };
        return {
                TAG: "Fun",
                _0: f,
                _1: {
                  hd: env,
                  tl: t._1
                },
                _2: transformedBody,
                _3: closureTuple
              };
    case "Join" :
        return {
                TAG: "Join",
                _0: t._0,
                _1: t._1,
                _2: go$2(t._2),
                _3: go$2(t._3)
              };
    case "Halt" :
    case "Jump" :
        return t;
    case "App" :
        var f$1 = t._1;
        var ptr = fresh("f");
        return {
                TAG: "Proj",
                _0: ptr,
                _1: f$1,
                _2: 0,
                _3: {
                  TAG: "App",
                  _0: t._0,
                  _1: ptr,
                  _2: {
                    hd: {
                      TAG: "AtomVar",
                      _0: f$1
                    },
                    tl: t._2
                  },
                  _3: go$2(t._3)
                }
              };
    case "Bop" :
        return {
                TAG: "Bop",
                _0: t._0,
                _1: t._1,
                _2: t._2,
                _3: t._3,
                _4: go$2(t._4)
              };
    case "If" :
        return {
                TAG: "If",
                _0: t._0,
                _1: go$2(t._1),
                _2: go$2(t._2)
              };
    case "Tuple" :
        return {
                TAG: "Tuple",
                _0: t._0,
                _1: t._1,
                _2: go$2(t._2)
              };
    case "Proj" :
        return {
                TAG: "Proj",
                _0: t._0,
                _1: t._1,
                _2: t._2,
                _3: go$2(t._3)
              };
    
  }
}

var ClosureConversion = {
  convert: go$2
};

function printAtom(atom) {
  switch (atom.TAG) {
    case "AtomInt" :
        return atom._0.toString();
    case "AtomVar" :
        return atom._0;
    case "AtomGlob" :
        return "@" + atom._0;
    
  }
}

function printANF(t) {
  switch (t.TAG) {
    case "Halt" :
        return "halt " + printAtom(t._0);
    case "Fun" :
        var params = Core__List.toArray(t._1).join(", ");
        return "fun " + t._0 + "(" + params + ") =\n  " + printANF(t._2) + "\nin\n" + printANF(t._3);
    case "Join" :
        var p = t._1;
        var j = t._0;
        if (p !== undefined) {
          return "join " + j + "(" + p + ") =\n  " + printANF(t._2) + "\nin\n" + printANF(t._3);
        } else {
          return "join " + j + " =\n  " + printANF(t._2) + "\nin\n" + printANF(t._3);
        }
    case "Jump" :
        var atom = t._1;
        var j$1 = t._0;
        if (atom !== undefined) {
          return "jump " + j$1 + "(" + printAtom(atom) + ")";
        } else {
          return "jump " + j$1;
        }
    case "App" :
        var args = Core__List.toArray(Core__List.map(t._2, printAtom)).join(", ");
        return "let " + t._0 + " = " + t._1 + "(" + args + ") in\n" + printANF(t._3);
    case "Bop" :
        var r = t._0;
        if (t._1 === "Plus") {
          return "let " + r + " = " + printAtom(t._2) + " + " + printAtom(t._3) + " in\n" + printANF(t._4);
        } else {
          return "let " + r + " = " + printAtom(t._2) + " - " + printAtom(t._3) + " in\n" + printANF(t._4);
        }
    case "If" :
        return "if " + printAtom(t._0) + " then\n  " + printANF(t._1) + "\nelse\n  " + printANF(t._2);
    case "Tuple" :
        var values = Core__List.toArray(Core__List.map(t._1, printAtom)).join(", ");
        return "let " + t._0 + " = (" + values + ") in\n" + printANF(t._2);
    case "Proj" :
        return "let " + t._0 + " = " + t._1 + "." + t._2.toString() + " in\n" + printANF(t._3);
    
  }
}

function printLam(t) {
  switch (t.TAG) {
    case "Int" :
        return t._0.toString();
    case "Var" :
        return t._0;
    case "Lam" :
        return "(Î»" + t._0 + ". " + printLam(t._1) + ")";
    case "App" :
        return "(" + printLam(t._0) + " " + printLam(t._1) + ")";
    case "Bop" :
        if (t._0 === "Plus") {
          return "(" + printLam(t._1) + " + " + printLam(t._2) + ")";
        } else {
          return "(" + printLam(t._1) + " - " + printLam(t._2) + ")";
        }
    case "If" :
        return "if " + printLam(t._0) + " then " + printLam(t._1) + " else " + printLam(t._2);
    
  }
}

var Print = {
  printAtom: printAtom,
  printANF: printANF,
  printLam: printLam
};

var testLambda = {
  TAG: "Lam",
  _0: "x",
  _1: {
    TAG: "Var",
    _0: "x"
  }
};

var testApp = {
  TAG: "App",
  _0: {
    TAG: "Lam",
    _0: "x",
    _1: {
      TAG: "Var",
      _0: "x"
    }
  },
  _1: {
    TAG: "Int",
    _0: 42
  }
};

var testBop = {
  TAG: "Bop",
  _0: "Plus",
  _1: {
    TAG: "Int",
    _0: 3
  },
  _2: {
    TAG: "Int",
    _0: 4
  }
};

var testIf = {
  TAG: "If",
  _0: {
    TAG: "Int",
    _0: 1
  },
  _1: {
    TAG: "Int",
    _0: 2
  },
  _2: {
    TAG: "Int",
    _0: 3
  }
};

console.log("=== Original Lambda Terms ===");

console.log("Identity function:", printLam(testLambda));

console.log("Application:", printLam(testApp));

console.log("Binary operation:", printLam(testBop));

console.log("If expression:", printLam(testIf));

console.log("\n=== After Alpha Renaming ===");

var renamedLambda = rename(testLambda);

var renamedApp = rename(testApp);

var renamedBop = rename(testBop);

var renamedIf = rename(testIf);

console.log("Identity function:", printLam(renamedLambda));

console.log("Application:", printLam(renamedApp));

console.log("Binary operation:", printLam(renamedBop));

console.log("If expression:", printLam(renamedIf));

console.log("\n=== After ANF Conversion ===");

var anfLambda = go$1(renamedLambda, mkHalt);

var anfApp = go$1(renamedApp, mkHalt);

var anfBop = go$1(renamedBop, mkHalt);

var anfIf = go$1(renamedIf, mkHalt);

console.log("Identity function:", printANF(anfLambda));

console.log("Application:", printANF(anfApp));

console.log("Binary operation:", printANF(anfBop));

console.log("If expression:", printANF(anfIf));

console.log("\n=== After Closure Conversion ===");

var closureLambda = go$2(anfLambda);

var closureApp = go$2(anfApp);

var closureBop = go$2(anfBop);

var closureIf = go$2(anfIf);

console.log("Identity function:", printANF(closureLambda));

console.log("Application:", printANF(closureApp));

console.log("Binary operation:", printANF(closureBop));

console.log("If expression:", printANF(closureIf));

export {
  Lam ,
  ANF ,
  FreeVars ,
  ClosureConversion ,
  Print ,
  testLambda ,
  testApp ,
  testBop ,
  testIf ,
  renamedLambda ,
  renamedApp ,
  renamedBop ,
  renamedIf ,
  anfLambda ,
  anfApp ,
  anfBop ,
  anfIf ,
  closureLambda ,
  closureApp ,
  closureBop ,
  closureIf ,
}
/* rename Not a pure module */
