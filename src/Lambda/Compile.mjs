// Generated by ReScript, PLEASE EDIT WITH CARE

import * as ANF from "./ANF.mjs";
import * as Ast from "./Ast.mjs";
import * as Hoisting from "./Hoisting.mjs";
import * as Core__List from "@rescript/core/src/Core__List.mjs";
import * as Core__Array from "@rescript/core/src/Core__Array.mjs";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";
import * as ClosureConversion from "./ClosureConversion.mjs";

function atomToLLVM(atom) {
  switch (atom.TAG) {
    case "AtomInt" :
        return atom._0.toString();
    case "AtomVar" :
        return "%" + atom._0;
    case "AtomGlob" :
        return "@" + atom._0;
    
  }
}

function atomToTypedLLVM(atom) {
  return "i64 " + atomToLLVM(atom);
}

function bopToLLVM(r, bop, x, y) {
  var x$1 = atomToLLVM(x);
  var y$1 = atomToLLVM(y);
  if (bop === "Plus") {
    return "%" + r + " = add i64 " + x$1 + ", " + y$1;
  } else {
    return "%" + r + " = sub i64 " + x$1 + ", " + y$1;
  }
}

function lowerPhase1(anf) {
  var go = function (_t, _insts) {
    while(true) {
      var insts = _insts;
      var t = _t;
      switch (t.TAG) {
        case "Halt" :
            var n = t._0;
            switch (n.TAG) {
              case "AtomInt" :
                  return Core__List.add(insts, "ret i64 " + n._0.toString());
              case "AtomVar" :
                  return Core__List.add(insts, "ret i64 %" + n._0);
              case "AtomGlob" :
                  return PervasivesU.failwith("Phase 1: Unsupported ANF construct");
              
            }
        case "Bop" :
            _insts = Core__List.add(insts, bopToLLVM(t._0, t._1, t._2, t._3));
            _t = t._4;
            continue ;
        default:
          return PervasivesU.failwith("Phase 1: Unsupported ANF construct");
      }
    };
  };
  var insts = go(anf, /* [] */0);
  var body = Core__List.toArray(Core__List.reverse(insts)).join("\n  ");
  return "define i64 @main() {\nentry:\n  " + body + "\n}";
}

function lowerPhase2(anf) {
  var functions = {
    contents: /* [] */0
  };
  var mainInstructions = {
    contents: /* [] */0
  };
  var extractFunctions = function (_t) {
    while(true) {
      var t = _t;
      switch (t.TAG) {
        case "Halt" :
            var x = t._0;
            switch (x.TAG) {
              case "AtomInt" :
                  mainInstructions.contents = {
                    hd: "ret i64 " + x._0.toString(),
                    tl: mainInstructions.contents
                  };
                  return ;
              case "AtomVar" :
                  var x$1 = x._0;
                  var isFunctionName = Core__List.some(functions.contents, (function(x$1){
                      return function (funcDef) {
                        return funcDef.includes("@" + x$1 + "(");
                      }
                      }(x$1)));
                  if (isFunctionName) {
                    return PervasivesU.failwith("Phase 2: Function references not yet supported: " + x$1);
                  } else {
                    mainInstructions.contents = {
                      hd: "ret i64 %" + x$1,
                      tl: mainInstructions.contents
                    };
                    return ;
                  }
              case "AtomGlob" :
                  return PervasivesU.failwith("Phase 2: Unsupported ANF construct");
              
            }
        case "Fun" :
            var paramList = Core__List.toArray(Core__List.map(t._1, (function (p) {
                          return "i64 %" + p;
                        }))).join(", ");
            var bodyInstructions = {
              contents: /* [] */0
            };
            var generateBody = (function(bodyInstructions){
            return function generateBody(_bodyTerm) {
              while(true) {
                var bodyTerm = _bodyTerm;
                switch (bodyTerm.TAG) {
                  case "Halt" :
                      var n = bodyTerm._0;
                      switch (n.TAG) {
                        case "AtomInt" :
                            bodyInstructions.contents = {
                              hd: "ret i64 " + n._0.toString(),
                              tl: bodyInstructions.contents
                            };
                            return ;
                        case "AtomVar" :
                            bodyInstructions.contents = {
                              hd: "ret i64 %" + n._0,
                              tl: bodyInstructions.contents
                            };
                            return ;
                        case "AtomGlob" :
                            return PervasivesU.failwith("Phase 2: Unsupported construct in function body");
                        
                      }
                  case "Bop" :
                      var r = bodyTerm._0;
                      if (bodyTerm._1 === "Plus") {
                        bodyInstructions.contents = {
                          hd: "%" + r + " = add i64 " + atomToLLVM(bodyTerm._2) + ", " + atomToLLVM(bodyTerm._3),
                          tl: bodyInstructions.contents
                        };
                        _bodyTerm = bodyTerm._4;
                        continue ;
                      }
                      bodyInstructions.contents = {
                        hd: "%" + r + " = sub i64 " + atomToLLVM(bodyTerm._2) + ", " + atomToLLVM(bodyTerm._3),
                        tl: bodyInstructions.contents
                      };
                      _bodyTerm = bodyTerm._4;
                      continue ;
                  default:
                    return PervasivesU.failwith("Phase 2: Unsupported construct in function body");
                }
              };
            }
            }(bodyInstructions));
            generateBody(t._2);
            var bodyStr = Core__List.toArray(Core__List.reverse(bodyInstructions.contents)).join("\n  ");
            var funcDef = "define i64 @" + t._0 + "(" + paramList + ") {\nentry:\n  " + bodyStr + "\n}";
            functions.contents = {
              hd: funcDef,
              tl: functions.contents
            };
            _t = t._3;
            continue ;
        case "App" :
            var argList = Core__List.toArray(Core__List.map(t._2, atomToTypedLLVM)).join(", ");
            mainInstructions.contents = {
              hd: "%" + t._0 + " = call i64 @" + t._1 + "(" + argList + ")",
              tl: mainInstructions.contents
            };
            _t = t._3;
            continue ;
        case "Bop" :
            var r = t._0;
            if (t._1 === "Plus") {
              mainInstructions.contents = {
                hd: "%" + r + " = add i64 " + atomToLLVM(t._2) + ", " + atomToLLVM(t._3),
                tl: mainInstructions.contents
              };
              _t = t._4;
              continue ;
            }
            mainInstructions.contents = {
              hd: "%" + r + " = sub i64 " + atomToLLVM(t._2) + ", " + atomToLLVM(t._3),
              tl: mainInstructions.contents
            };
            _t = t._4;
            continue ;
        default:
          return PervasivesU.failwith("Phase 2: Unsupported ANF construct");
      }
    };
  };
  extractFunctions(anf);
  var functionsStr = Core__List.toArray(Core__List.reverse(functions.contents)).join("\n\n");
  var mainBody = Core__List.toArray(Core__List.reverse(mainInstructions.contents)).join("\n  ");
  var mainFunc = "define i64 @main() {\nentry:\n  " + mainBody + "\n}";
  if (Core__List.length(functions.contents) > 0) {
    return functionsStr + "\n\n" + mainFunc;
  } else {
    return mainFunc;
  }
}

function lowerPhase3(anf) {
  var functions = {
    contents: /* [] */0
  };
  var mainInstructions = {
    contents: /* [] */0
  };
  var extractFunctions = function (_t) {
    while(true) {
      var t = _t;
      switch (t.TAG) {
        case "Halt" :
            var x = t._0;
            switch (x.TAG) {
              case "AtomInt" :
                  mainInstructions.contents = {
                    hd: "ret i64 " + x._0.toString(),
                    tl: mainInstructions.contents
                  };
                  return ;
              case "AtomVar" :
                  var x$1 = x._0;
                  var isFunctionName = Core__List.some(functions.contents, (function(x$1){
                      return function (funcDef) {
                        return funcDef.includes("@" + x$1 + "(");
                      }
                      }(x$1)));
                  if (isFunctionName) {
                    return PervasivesU.failwith("Phase 3: Function references not yet supported: " + x$1);
                  } else {
                    mainInstructions.contents = {
                      hd: "ret i64 %" + x$1,
                      tl: mainInstructions.contents
                    };
                    return ;
                  }
              case "AtomGlob" :
                  return PervasivesU.failwith("Phase 3: Unsupported ANF construct");
              
            }
        case "Fun" :
            var paramList = Core__List.toArray(Core__List.map(t._1, (function (p) {
                          return "i64 %" + p;
                        }))).join(", ");
            var bodyInstructions = {
              contents: /* [] */0
            };
            var generateBody = (function(bodyInstructions){
            return function generateBody(_bodyTerm) {
              while(true) {
                var bodyTerm = _bodyTerm;
                switch (bodyTerm.TAG) {
                  case "Halt" :
                      var n = bodyTerm._0;
                      switch (n.TAG) {
                        case "AtomInt" :
                            bodyInstructions.contents = {
                              hd: "ret i64 " + n._0.toString(),
                              tl: bodyInstructions.contents
                            };
                            return ;
                        case "AtomVar" :
                            bodyInstructions.contents = {
                              hd: "ret i64 %" + n._0,
                              tl: bodyInstructions.contents
                            };
                            return ;
                        case "AtomGlob" :
                            return PervasivesU.failwith("Phase 3: Unsupported construct in function body");
                        
                      }
                  case "Bop" :
                      var r = bodyTerm._0;
                      if (bodyTerm._1 === "Plus") {
                        bodyInstructions.contents = {
                          hd: "%" + r + " = add i64 " + atomToLLVM(bodyTerm._2) + ", " + atomToLLVM(bodyTerm._3),
                          tl: bodyInstructions.contents
                        };
                        _bodyTerm = bodyTerm._4;
                        continue ;
                      }
                      bodyInstructions.contents = {
                        hd: "%" + r + " = sub i64 " + atomToLLVM(bodyTerm._2) + ", " + atomToLLVM(bodyTerm._3),
                        tl: bodyInstructions.contents
                      };
                      _bodyTerm = bodyTerm._4;
                      continue ;
                  case "Tuple" :
                      var vs = bodyTerm._1;
                      var r$1 = bodyTerm._0;
                      var size = Core__List.length(vs);
                      bodyInstructions.contents = {
                        hd: "%" + r$1 + "_ptr = alloca { " + Core__Array.make(size, "i64").join(", ") + " }",
                        tl: bodyInstructions.contents
                      };
                      Core__List.mapWithIndex(vs, (function(r$1,size){
                          return function (atom, i) {
                            var gepInstr = "%" + r$1 + "_gep" + i.toString() + " = getelementptr { " + Core__Array.make(size, "i64").join(", ") + " }, { " + Core__Array.make(size, "i64").join(", ") + " }* %" + r$1 + "_ptr, i32 0, i32 " + i.toString();
                            var storeInstr;
                            var exit = 0;
                            switch (atom.TAG) {
                              case "AtomInt" :
                              case "AtomVar" :
                                  exit = 1;
                                  break;
                              case "AtomGlob" :
                                  var tmpVar = r$1 + "_tmp" + i.toString();
                                  bodyInstructions.contents = {
                                    hd: "%" + tmpVar + " = ptrtoint i64 (i64, i64)* @" + atom._0 + " to i64",
                                    tl: bodyInstructions.contents
                                  };
                                  storeInstr = "store i64 %" + tmpVar + ", i64* %" + r$1 + "_gep" + i.toString();
                                  break;
                              
                            }
                            if (exit === 1) {
                              storeInstr = "store i64 " + atomToLLVM(atom) + ", i64* %" + r$1 + "_gep" + i.toString();
                            }
                            bodyInstructions.contents = {
                              hd: storeInstr,
                              tl: {
                                hd: gepInstr,
                                tl: bodyInstructions.contents
                              }
                            };
                          }
                          }(r$1,size)));
                      bodyInstructions.contents = {
                        hd: "%" + r$1 + " = ptrtoint { " + Core__Array.make(size, "i64").join(", ") + " }* %" + r$1 + "_ptr to i64",
                        tl: bodyInstructions.contents
                      };
                      _bodyTerm = bodyTerm._2;
                      continue ;
                  case "Proj" :
                      var x = bodyTerm._1;
                      var r$2 = bodyTerm._0;
                      var ptrVar = x + "_ptr_" + r$2;
                      var gepVar = r$2 + "_gep";
                      bodyInstructions.contents = {
                        hd: "%" + ptrVar + " = inttoptr i64 %" + x + " to { i64, i64, i64 }*",
                        tl: bodyInstructions.contents
                      };
                      bodyInstructions.contents = {
                        hd: "%" + gepVar + " = getelementptr { i64, i64, i64 }, { i64, i64, i64 }* %" + ptrVar + ", i32 0, i32 " + bodyTerm._2.toString(),
                        tl: bodyInstructions.contents
                      };
                      bodyInstructions.contents = {
                        hd: "%" + r$2 + " = load i64, i64* %" + gepVar,
                        tl: bodyInstructions.contents
                      };
                      _bodyTerm = bodyTerm._3;
                      continue ;
                  default:
                    return PervasivesU.failwith("Phase 3: Unsupported construct in function body");
                }
              };
            }
            }(bodyInstructions));
            generateBody(t._2);
            var bodyStr = Core__List.toArray(Core__List.reverse(bodyInstructions.contents)).join("\n  ");
            var funcDef = "define i64 @" + t._0 + "(" + paramList + ") {\nentry:\n  " + bodyStr + "\n}";
            functions.contents = {
              hd: funcDef,
              tl: functions.contents
            };
            _t = t._3;
            continue ;
        case "App" :
            var f = t._1;
            var argList = Core__List.toArray(Core__List.map(t._2, (function (atom) {
                          switch (atom.TAG) {
                            case "AtomInt" :
                                return "i64 " + atom._0.toString();
                            case "AtomVar" :
                                return "i64 %" + atom._0;
                            case "AtomGlob" :
                                return "i64 @" + atom._0;
                            
                          }
                        }))).join(", ");
            var fptrVar = f + "_fptr";
            mainInstructions.contents = {
              hd: "%" + fptrVar + " = inttoptr i64 %" + f + " to i64 (i64, i64)*",
              tl: mainInstructions.contents
            };
            mainInstructions.contents = {
              hd: "%" + t._0 + " = call i64 %" + fptrVar + "(" + argList + ")",
              tl: mainInstructions.contents
            };
            _t = t._3;
            continue ;
        case "Bop" :
            var r = t._0;
            if (t._1 === "Plus") {
              mainInstructions.contents = {
                hd: "%" + r + " = add i64 " + atomToLLVM(t._2) + ", " + atomToLLVM(t._3),
                tl: mainInstructions.contents
              };
              _t = t._4;
              continue ;
            }
            mainInstructions.contents = {
              hd: "%" + r + " = sub i64 " + atomToLLVM(t._2) + ", " + atomToLLVM(t._3),
              tl: mainInstructions.contents
            };
            _t = t._4;
            continue ;
        case "Tuple" :
            var vs = t._1;
            var r$1 = t._0;
            var size = Core__List.length(vs);
            mainInstructions.contents = {
              hd: "%" + r$1 + "_ptr = alloca { " + Core__Array.make(size, "i64").join(", ") + " }",
              tl: mainInstructions.contents
            };
            Core__List.mapWithIndex(vs, (function(r$1,size){
                return function (atom, i) {
                  var gepInstr = "%" + r$1 + "_gep" + i.toString() + " = getelementptr { " + Core__Array.make(size, "i64").join(", ") + " }, { " + Core__Array.make(size, "i64").join(", ") + " }* %" + r$1 + "_ptr, i32 0, i32 " + i.toString();
                  var storeInstr;
                  var exit = 0;
                  switch (atom.TAG) {
                    case "AtomInt" :
                    case "AtomVar" :
                        exit = 1;
                        break;
                    case "AtomGlob" :
                        var tmpVar = r$1 + "_tmp" + i.toString();
                        mainInstructions.contents = {
                          hd: "%" + tmpVar + " = ptrtoint i64 (i64, i64)* @" + atom._0 + " to i64",
                          tl: mainInstructions.contents
                        };
                        storeInstr = "store i64 %" + tmpVar + ", i64* %" + r$1 + "_gep" + i.toString();
                        break;
                    
                  }
                  if (exit === 1) {
                    storeInstr = "store i64 " + atomToLLVM(atom) + ", i64* %" + r$1 + "_gep" + i.toString();
                  }
                  mainInstructions.contents = {
                    hd: storeInstr,
                    tl: {
                      hd: gepInstr,
                      tl: mainInstructions.contents
                    }
                  };
                }
                }(r$1,size)));
            mainInstructions.contents = {
              hd: "%" + r$1 + " = ptrtoint { " + Core__Array.make(size, "i64").join(", ") + " }* %" + r$1 + "_ptr to i64",
              tl: mainInstructions.contents
            };
            _t = t._2;
            continue ;
        case "Proj" :
            var x$2 = t._1;
            var r$2 = t._0;
            var ptrVar = x$2 + "_ptr_" + r$2;
            var gepVar = r$2 + "_gep";
            mainInstructions.contents = {
              hd: "%" + ptrVar + " = inttoptr i64 %" + x$2 + " to { i64, i64, i64 }*",
              tl: mainInstructions.contents
            };
            mainInstructions.contents = {
              hd: "%" + gepVar + " = getelementptr { i64, i64, i64 }, { i64, i64, i64 }* %" + ptrVar + ", i32 0, i32 " + t._2.toString(),
              tl: mainInstructions.contents
            };
            mainInstructions.contents = {
              hd: "%" + r$2 + " = load i64, i64* %" + gepVar,
              tl: mainInstructions.contents
            };
            _t = t._3;
            continue ;
        default:
          return PervasivesU.failwith("Phase 3: Unsupported ANF construct");
      }
    };
  };
  extractFunctions(anf);
  var functionsStr = Core__List.toArray(Core__List.reverse(functions.contents)).join("\n\n");
  var mainBody = Core__List.toArray(Core__List.reverse(mainInstructions.contents)).join("\n  ");
  var mainFunc = "define i64 @main() {\nentry:\n  " + mainBody + "\n}";
  if (Core__List.length(functions.contents) > 0) {
    return functionsStr + "\n\n" + mainFunc;
  } else {
    return mainFunc;
  }
}

function lowerPhase4(anf) {
  var functions = {
    contents: /* [] */0
  };
  var mainInstructions = {
    contents: /* [] */0
  };
  var labelCounter = {
    contents: 0
  };
  var getNextLabel = function (prefix) {
    labelCounter.contents = labelCounter.contents + 1 | 0;
    return prefix + labelCounter.contents.toString();
  };
  var extractFunctions = function (_t) {
    while(true) {
      var t = _t;
      switch (t.TAG) {
        case "Halt" :
            var x = t._0;
            switch (x.TAG) {
              case "AtomInt" :
                  mainInstructions.contents = {
                    hd: "ret i64 " + x._0.toString(),
                    tl: mainInstructions.contents
                  };
                  return ;
              case "AtomVar" :
                  var x$1 = x._0;
                  var isFunctionName = Core__List.some(functions.contents, (function(x$1){
                      return function (funcDef) {
                        return funcDef.includes("@" + x$1 + "(");
                      }
                      }(x$1)));
                  if (isFunctionName) {
                    return PervasivesU.failwith("Phase 4: Function references not yet supported: " + x$1);
                  } else {
                    mainInstructions.contents = {
                      hd: "ret i64 %" + x$1,
                      tl: mainInstructions.contents
                    };
                    return ;
                  }
              case "AtomGlob" :
                  return PervasivesU.failwith("Phase 4: Unsupported ANF construct");
              
            }
        case "Fun" :
            var paramList = Core__List.toArray(Core__List.map(t._1, (function (p) {
                          return "i64 %" + p;
                        }))).join(", ");
            var bodyInstructions = {
              contents: /* [] */0
            };
            var generateBody = (function(bodyInstructions){
            return function generateBody(_bodyTerm) {
              while(true) {
                var bodyTerm = _bodyTerm;
                switch (bodyTerm.TAG) {
                  case "Halt" :
                      var n = bodyTerm._0;
                      switch (n.TAG) {
                        case "AtomInt" :
                            bodyInstructions.contents = {
                              hd: "ret i64 " + n._0.toString(),
                              tl: bodyInstructions.contents
                            };
                            return ;
                        case "AtomVar" :
                            bodyInstructions.contents = {
                              hd: "ret i64 %" + n._0,
                              tl: bodyInstructions.contents
                            };
                            return ;
                        case "AtomGlob" :
                            break;
                        
                      }
                      break;
                  case "Bop" :
                      var r = bodyTerm._0;
                      if (bodyTerm._1 === "Plus") {
                        bodyInstructions.contents = {
                          hd: "%" + r + " = add i64 " + atomToLLVM(bodyTerm._2) + ", " + atomToLLVM(bodyTerm._3),
                          tl: bodyInstructions.contents
                        };
                        _bodyTerm = bodyTerm._4;
                        continue ;
                      }
                      bodyInstructions.contents = {
                        hd: "%" + r + " = sub i64 " + atomToLLVM(bodyTerm._2) + ", " + atomToLLVM(bodyTerm._3),
                        tl: bodyInstructions.contents
                      };
                      _bodyTerm = bodyTerm._4;
                      continue ;
                  case "If" :
                      var thenLabel = getNextLabel("then");
                      var elseLabel = getNextLabel("else");
                      bodyInstructions.contents = {
                        hd: "%cond = icmp ne i64 " + atomToLLVM(bodyTerm._0) + ", 0",
                        tl: bodyInstructions.contents
                      };
                      bodyInstructions.contents = {
                        hd: "br i1 %cond, label %" + thenLabel + ", label %" + elseLabel,
                        tl: bodyInstructions.contents
                      };
                      bodyInstructions.contents = {
                        hd: thenLabel + ":",
                        tl: bodyInstructions.contents
                      };
                      generateBody(bodyTerm._1);
                      bodyInstructions.contents = {
                        hd: elseLabel + ":",
                        tl: bodyInstructions.contents
                      };
                      _bodyTerm = bodyTerm._2;
                      continue ;
                  default:
                    
                }
                return PervasivesU.failwith("Phase 4: Unsupported construct in function body: " + ANF.printANF(bodyTerm));
              };
            }
            }(bodyInstructions));
            generateBody(t._2);
            var bodyStr = Core__List.toArray(Core__List.reverse(bodyInstructions.contents)).join("\n  ");
            var funcDef = "define i64 @" + t._0 + "(" + paramList + ") {\nentry:\n  " + bodyStr + "\n}";
            functions.contents = {
              hd: funcDef,
              tl: functions.contents
            };
            _t = t._3;
            continue ;
        case "Join" :
            return PervasivesU.failwith("Code must be straightline!");
        case "Jump" :
            if (t._1 !== undefined) {
              return PervasivesU.failwith("Phase 4: Unsupported ANF construct");
            } else {
              mainInstructions.contents = {
                hd: "br label %" + t._0,
                tl: mainInstructions.contents
              };
              return ;
            }
        case "Bop" :
            var r = t._0;
            if (t._1 === "Plus") {
              mainInstructions.contents = {
                hd: "%" + r + " = add i64 " + atomToLLVM(t._2) + ", " + atomToLLVM(t._3),
                tl: mainInstructions.contents
              };
              _t = t._4;
              continue ;
            }
            mainInstructions.contents = {
              hd: "%" + r + " = sub i64 " + atomToLLVM(t._2) + ", " + atomToLLVM(t._3),
              tl: mainInstructions.contents
            };
            _t = t._4;
            continue ;
        case "If" :
            var thenLabel = getNextLabel("then");
            var elseLabel = getNextLabel("else");
            mainInstructions.contents = {
              hd: "%cond = icmp ne i64 " + atomToLLVM(t._0) + ", 0",
              tl: mainInstructions.contents
            };
            mainInstructions.contents = {
              hd: "br i1 %cond, label %" + thenLabel + ", label %" + elseLabel,
              tl: mainInstructions.contents
            };
            mainInstructions.contents = {
              hd: thenLabel + ":",
              tl: mainInstructions.contents
            };
            extractFunctions(t._1);
            mainInstructions.contents = {
              hd: elseLabel + ":",
              tl: mainInstructions.contents
            };
            _t = t._2;
            continue ;
        default:
          return PervasivesU.failwith("Phase 4: Unsupported ANF construct");
      }
    };
  };
  extractFunctions(anf);
  var functionsStr = Core__List.toArray(Core__List.reverse(functions.contents)).join("\n\n");
  var mainBody = Core__List.toArray(Core__List.reverse(mainInstructions.contents)).join("\n  ");
  var mainFunc = "define i64 @main() {\nentry:\n  " + mainBody + "\n}";
  if (Core__List.length(functions.contents) > 0) {
    return functionsStr + "\n\n" + mainFunc;
  } else {
    return mainFunc;
  }
}

var LLVMLowering = {
  atomToLLVM: atomToLLVM,
  atomToTypedLLVM: atomToTypedLLVM,
  bopToLLVM: bopToLLVM,
  lowerPhase1: lowerPhase1,
  lowerPhase2: lowerPhase2,
  lowerPhase3: lowerPhase3,
  lowerPhase4: lowerPhase4
};

function compile(term) {
  return Hoisting.hoist(ClosureConversion.convert(ANF.convert(Ast.rename(term))));
}

function compileToLLVM(term, phase) {
  var anf = compile(term);
  switch (phase) {
    case 1 :
        return lowerPhase1(anf);
    case 2 :
        return lowerPhase2(anf);
    case 3 :
        return lowerPhase3(anf);
    case 4 :
        return lowerPhase4(anf);
    default:
      return PervasivesU.failwith("Unsupported LLVM lowering phase");
  }
}

var Compiler = {
  compile: compile,
  compileToLLVM: compileToLLVM
};

export {
  LLVMLowering ,
  Compiler ,
}
/* ANF Not a pure module */
