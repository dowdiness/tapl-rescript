// Generated by ReScript, PLEASE EDIT WITH CARE

import * as ANF from "./ANF.mjs";
import * as Ast from "./Ast.mjs";
import * as Parser from "./Parser.mjs";
import * as Compile from "./Compile.mjs";
import * as Belt_SetString from "rescript/lib/es6/belt_SetString.js";
import * as ClosureConversion from "./ClosureConversion.mjs";

var testLambda = {
  TAG: "Lam",
  _0: "x",
  _1: {
    TAG: "Var",
    _0: "x"
  }
};

var testApp = {
  TAG: "App",
  _0: {
    TAG: "Lam",
    _0: "x",
    _1: {
      TAG: "Var",
      _0: "x"
    }
  },
  _1: {
    TAG: "Int",
    _0: 42
  }
};

var testBop = {
  TAG: "Bop",
  _0: "Plus",
  _1: {
    TAG: "Int",
    _0: 3
  },
  _2: {
    TAG: "Int",
    _0: 4
  }
};

var testIf = {
  TAG: "If",
  _0: {
    TAG: "Int",
    _0: 1
  },
  _1: {
    TAG: "Int",
    _0: 2
  },
  _2: {
    TAG: "Int",
    _0: 3
  }
};

var testNested = {
  TAG: "Lam",
  _0: "x",
  _1: {
    TAG: "App",
    _0: {
      TAG: "Lam",
      _0: "y",
      _1: {
        TAG: "App",
        _0: {
          TAG: "Lam",
          _0: "z",
          _1: {
            TAG: "Bop",
            _0: "Plus",
            _1: {
              TAG: "Var",
              _0: "x"
            },
            _2: {
              TAG: "Bop",
              _0: "Plus",
              _1: {
                TAG: "Var",
                _0: "y"
              },
              _2: {
                TAG: "Var",
                _0: "z"
              }
            }
          }
        },
        _1: {
          TAG: "Int",
          _0: 3
        }
      }
    },
    _1: {
      TAG: "Int",
      _0: 2
    }
  }
};

var testCurried = {
  TAG: "Lam",
  _0: "x",
  _1: {
    TAG: "Lam",
    _0: "y",
    _1: {
      TAG: "Bop",
      _0: "Plus",
      _1: {
        TAG: "Var",
        _0: "x"
      },
      _2: {
        TAG: "Var",
        _0: "y"
      }
    }
  }
};

var testComplexFreeVars = {
  TAG: "App",
  _0: {
    TAG: "Lam",
    _0: "a",
    _1: {
      TAG: "App",
      _0: {
        TAG: "Lam",
        _0: "b",
        _1: {
          TAG: "App",
          _0: {
            TAG: "Lam",
            _0: "c",
            _1: {
              TAG: "Bop",
              _0: "Plus",
              _1: {
                TAG: "Var",
                _0: "a"
              },
              _2: {
                TAG: "Bop",
                _0: "Plus",
                _1: {
                  TAG: "Var",
                  _0: "b"
                },
                _2: {
                  TAG: "Var",
                  _0: "c"
                }
              }
            }
          },
          _1: {
            TAG: "Bop",
            _0: "Plus",
            _1: {
              TAG: "Var",
              _0: "a"
            },
            _2: {
              TAG: "Var",
              _0: "b"
            }
          }
        }
      },
      _1: {
        TAG: "Bop",
        _0: "Plus",
        _1: {
          TAG: "Var",
          _0: "a"
        },
        _2: {
          TAG: "Int",
          _0: 1
        }
      }
    }
  },
  _1: {
    TAG: "Int",
    _0: 10
  }
};

var testConditionalNested = {
  TAG: "If",
  _0: {
    TAG: "Int",
    _0: 1
  },
  _1: {
    TAG: "Lam",
    _0: "x",
    _1: {
      TAG: "Bop",
      _0: "Plus",
      _1: {
        TAG: "Var",
        _0: "x"
      },
      _2: {
        TAG: "Int",
        _0: 1
      }
    }
  },
  _2: {
    TAG: "Lam",
    _0: "y",
    _1: {
      TAG: "Bop",
      _0: "Minus",
      _1: {
        TAG: "Var",
        _0: "y"
      },
      _2: {
        TAG: "Int",
        _0: 1
      }
    }
  }
};

describe("Alpha Renaming", (function () {
        test("identity function", (function () {
                var renamed = Ast.rename(testLambda);
                var printed = Ast.printLam(renamed);
                expect(printed).toContain("λ");
                expect(printed).toMatch(new RegExp("x\\d+"));
              }));
        test("application", (function () {
                var renamed = Ast.rename(testApp);
                var printed = Ast.printLam(renamed);
                expect(printed).toContain("λ");
                expect(printed).toContain("42");
                expect(printed).toMatch(new RegExp("x\\d+"));
              }));
        test("binary operation", (function () {
                var renamed = Ast.rename(testBop);
                var printed = Ast.printLam(renamed);
                expect(printed).toContain("3");
                expect(printed).toContain("4");
                expect(printed).toContain("+");
              }));
        test("if expression", (function () {
                var renamed = Ast.rename(testIf);
                var printed = Ast.printLam(renamed);
                expect(printed).toContain("if");
                expect(printed).toContain("then");
                expect(printed).toContain("else");
                expect(printed).toContain("1");
                expect(printed).toContain("2");
                expect(printed).toContain("3");
              }));
        test("nested functions preserve structure", (function () {
                var renamed = Ast.rename(testNested);
                var printed = Ast.printLam(renamed);
                expect(printed).toContain("λ");
                expect(printed).toContain("+");
                expect(printed).toContain("2");
                expect(printed).toContain("3");
              }));
        test("curried function maintains currying", (function () {
                var renamed = Ast.rename(testCurried);
                var printed = Ast.printLam(renamed);
                var lambdaCount = printed.split("λ").length - 1 | 0;
                expect(lambdaCount).toBe(2);
                expect(printed).toContain("+");
              }));
      }));

describe("ANF Conversion", (function () {
        test("identity function produces function definition", (function () {
                var renamed = Ast.rename(testLambda);
                var anf = ANF.convert(renamed);
                var printed = ANF.printANF(anf);
                expect(printed).toContain("fun");
                expect(printed).toContain("halt");
              }));
        test("application produces function call", (function () {
                var renamed = Ast.rename(testApp);
                var anf = ANF.convert(renamed);
                var printed = ANF.printANF(anf);
                expect(printed).toContain("fun");
                expect(printed).toContain("let");
                expect(printed).toContain("42");
              }));
        test("binary operation produces arithmetic", (function () {
                var renamed = Ast.rename(testBop);
                var anf = ANF.convert(renamed);
                var printed = ANF.printANF(anf);
                expect(printed).toContain("3 + 4");
                expect(printed).toContain("halt");
              }));
        test("if expression produces conditional", (function () {
                var renamed = Ast.rename(testIf);
                var anf = ANF.convert(renamed);
                var printed = ANF.printANF(anf);
                expect(printed).toContain("if");
                expect(printed).toContain("then");
                expect(printed).toContain("else");
                expect(printed).toContain("join");
                expect(printed).toContain("jump");
              }));
        test("nested functions produce multiple function definitions", (function () {
                var renamed = Ast.rename(testNested);
                var anf = ANF.convert(renamed);
                var printed = ANF.printANF(anf);
                var funCount = printed.split("fun ").length - 1 | 0;
                expect(funCount).toBeGreaterThan(1.0);
                expect(printed).toContain("halt");
              }));
        test("complex free variables handled correctly", (function () {
                var renamed = Ast.rename(testComplexFreeVars);
                var anf = ANF.convert(renamed);
                var printed = ANF.printANF(anf);
                expect(printed).toContain("fun");
                expect(printed).toContain("let");
                expect(printed).toContain("10");
              }));
      }));

describe("Free Variables Computation", (function () {
        test("simple halt", (function () {
                var fvs = ClosureConversion.collectFVs({
                      TAG: "Halt",
                      _0: {
                        TAG: "AtomVar",
                        _0: "x"
                      }
                    });
                expect(Belt_SetString.has(fvs, "x")).toBeTruthy();
              }));
        test("halt with integer", (function () {
                var fvs = ClosureConversion.collectFVs({
                      TAG: "Halt",
                      _0: {
                        TAG: "AtomInt",
                        _0: 42
                      }
                    });
                expect(Belt_SetString.size(fvs)).toBe(0);
              }));
        test("binary operation", (function () {
                var fvs = ClosureConversion.collectFVs({
                      TAG: "Bop",
                      _0: "r",
                      _1: "Plus",
                      _2: {
                        TAG: "AtomVar",
                        _0: "x"
                      },
                      _3: {
                        TAG: "AtomVar",
                        _0: "y"
                      },
                      _4: {
                        TAG: "Halt",
                        _0: {
                          TAG: "AtomVar",
                          _0: "r"
                        }
                      }
                    });
                expect(Belt_SetString.has(fvs, "x")).toBeTruthy();
                expect(Belt_SetString.has(fvs, "y")).toBeTruthy();
              }));
      }));

describe("Closure Conversion", (function () {
        test("identity function creates closure tuple", (function () {
                var renamed = Ast.rename(testLambda);
                var anf = ANF.convert(renamed);
                var closure = ClosureConversion.convert(anf);
                var printed = ANF.printANF(closure);
                expect(printed).toContain("fun");
                expect(printed).toContain("env");
                expect(printed).toContain("@");
              }));
        test("application uses closure projection", (function () {
                var renamed = Ast.rename(testApp);
                var anf = ANF.convert(renamed);
                var closure = ClosureConversion.convert(anf);
                var printed = ANF.printANF(closure);
                expect(printed).toContain("let");
                expect(printed).toContain(".0");
                expect(printed).toContain("42");
              }));
        test("binary operation unchanged", (function () {
                var renamed = Ast.rename(testBop);
                var anf = ANF.convert(renamed);
                var closure = ClosureConversion.convert(anf);
                var printed = ANF.printANF(closure);
                expect(printed).toContain("3 + 4");
                expect(printed).toContain("halt");
              }));
        test("nested functions create environment tuples", (function () {
                var renamed = Ast.rename(testNested);
                var anf = ANF.convert(renamed);
                var closure = ClosureConversion.convert(anf);
                var printed = ANF.printANF(closure);
                expect(printed).toContain("env");
                expect(printed).toContain("@");
                expect(printed).toContain("(");
              }));
      }));

describe("Hoisting", (function () {
        test("identity function hoists to top level", (function () {
                var renamed = Ast.rename(testLambda);
                var anf = ANF.convert(renamed);
                var closure = ClosureConversion.convert(anf);
                var hoisted = Compile.Hoisting.hoist(closure);
                var printed = ANF.printANF(hoisted);
                var funIndex = printed.indexOf("fun");
                var tupleIndex = printed.indexOf("(");
                expect(funIndex).toBeLessThan(tupleIndex);
              }));
        test("application maintains function order", (function () {
                var renamed = Ast.rename(testApp);
                var anf = ANF.convert(renamed);
                var closure = ClosureConversion.convert(anf);
                var hoisted = Compile.Hoisting.hoist(closure);
                var printed = ANF.printANF(hoisted);
                expect(printed).toContain("fun");
                expect(printed).toContain("let");
                expect(printed).toContain("42");
              }));
        test("binary operation structure preserved", (function () {
                var renamed = Ast.rename(testBop);
                var anf = ANF.convert(renamed);
                var closure = ClosureConversion.convert(anf);
                var hoisted = Compile.Hoisting.hoist(closure);
                var printed = ANF.printANF(hoisted);
                expect(printed).toContain("3 + 4");
                expect(printed).toContain("halt");
              }));
        test("complex expressions have proper function ordering", (function () {
                var renamed = Ast.rename(testComplexFreeVars);
                var anf = ANF.convert(renamed);
                var closure = ClosureConversion.convert(anf);
                var hoisted = Compile.Hoisting.hoist(closure);
                var printed = ANF.printANF(hoisted);
                var lines = printed.split("\n");
                var funLines = lines.filter(function (line) {
                      return line.includes("fun ");
                    });
                expect(funLines.length).toBeGreaterThan(0.0);
              }));
      }));

describe("LLVM Lowering Phase 1", (function () {
        test("simple integer halt", (function () {
                var llvm = Compile.LLVMLowering.lowerPhase1({
                      TAG: "Halt",
                      _0: {
                        TAG: "AtomInt",
                        _0: 42
                      }
                    });
                expect(llvm).toContain("ret i64 42");
                expect(llvm).toContain("define i64 @main()");
              }));
        test("basic addition with integers", (function () {
                var llvm = Compile.LLVMLowering.lowerPhase1({
                      TAG: "Bop",
                      _0: "r",
                      _1: "Plus",
                      _2: {
                        TAG: "AtomInt",
                        _0: 3
                      },
                      _3: {
                        TAG: "AtomInt",
                        _0: 4
                      },
                      _4: {
                        TAG: "Halt",
                        _0: {
                          TAG: "AtomVar",
                          _0: "r"
                        }
                      }
                    });
                expect(llvm).toContain("add i64 3, 4");
                expect(llvm).toContain("ret i64 %r");
              }));
        test("basic subtraction with integers", (function () {
                var llvm = Compile.LLVMLowering.lowerPhase1({
                      TAG: "Bop",
                      _0: "s",
                      _1: "Minus",
                      _2: {
                        TAG: "AtomInt",
                        _0: 10
                      },
                      _3: {
                        TAG: "AtomInt",
                        _0: 3
                      },
                      _4: {
                        TAG: "Halt",
                        _0: {
                          TAG: "AtomVar",
                          _0: "s"
                        }
                      }
                    });
                expect(llvm).toContain("sub i64 10, 3");
                expect(llvm).toContain("ret i64 %s");
              }));
        test("mixed variable and integer operations", (function () {
                var llvm = Compile.LLVMLowering.lowerPhase1({
                      TAG: "Bop",
                      _0: "r",
                      _1: "Plus",
                      _2: {
                        TAG: "AtomVar",
                        _0: "x"
                      },
                      _3: {
                        TAG: "AtomInt",
                        _0: 5
                      },
                      _4: {
                        TAG: "Halt",
                        _0: {
                          TAG: "AtomVar",
                          _0: "r"
                        }
                      }
                    });
                expect(llvm).toContain("add i64 %x, 5");
              }));
      }));

describe("LLVM Lowering Phase 2", (function () {
        test("function call", (function () {
                var llvm = Compile.LLVMLowering.lowerPhase2({
                      TAG: "Fun",
                      _0: "double",
                      _1: {
                        hd: "x",
                        tl: /* [] */0
                      },
                      _2: {
                        TAG: "Bop",
                        _0: "r",
                        _1: "Plus",
                        _2: {
                          TAG: "AtomVar",
                          _0: "x"
                        },
                        _3: {
                          TAG: "AtomVar",
                          _0: "x"
                        },
                        _4: {
                          TAG: "Halt",
                          _0: {
                            TAG: "AtomVar",
                            _0: "r"
                          }
                        }
                      },
                      _3: {
                        TAG: "App",
                        _0: "result",
                        _1: "double",
                        _2: {
                          hd: {
                            TAG: "AtomInt",
                            _0: 21
                          },
                          tl: /* [] */0
                        },
                        _3: {
                          TAG: "Halt",
                          _0: {
                            TAG: "AtomVar",
                            _0: "result"
                          }
                        }
                      }
                    });
                expect(llvm).toContain("define i64 @double(i64 %x)");
                expect(llvm).toContain("call i64 @double(i64 21)");
              }));
        test("function with arithmetic in body", (function () {
                expect(function () {
                        return Compile.LLVMLowering.lowerPhase2({
                                    TAG: "Fun",
                                    _0: "addOne",
                                    _1: {
                                      hd: "x",
                                      tl: /* [] */0
                                    },
                                    _2: {
                                      TAG: "Bop",
                                      _0: "r",
                                      _1: "Plus",
                                      _2: {
                                        TAG: "AtomVar",
                                        _0: "x"
                                      },
                                      _3: {
                                        TAG: "AtomInt",
                                        _0: 1
                                      },
                                      _4: {
                                        TAG: "Halt",
                                        _0: {
                                          TAG: "AtomVar",
                                          _0: "r"
                                        }
                                      }
                                    },
                                    _3: {
                                      TAG: "Halt",
                                      _0: {
                                        TAG: "AtomVar",
                                        _0: "addOne"
                                      }
                                    }
                                  });
                      }).toThrow();
              }));
      }));

describe("LLVM Lowering Phase 3", (function () {
        test("simple tuple creation and projection", (function () {
                var llvm = Compile.LLVMLowering.lowerPhase3({
                      TAG: "Tuple",
                      _0: "t",
                      _1: {
                        hd: {
                          TAG: "AtomInt",
                          _0: 10
                        },
                        tl: {
                          hd: {
                            TAG: "AtomInt",
                            _0: 20
                          },
                          tl: {
                            hd: {
                              TAG: "AtomInt",
                              _0: 30
                            },
                            tl: /* [] */0
                          }
                        }
                      },
                      _2: {
                        TAG: "Proj",
                        _0: "x",
                        _1: "t",
                        _2: 1,
                        _3: {
                          TAG: "Halt",
                          _0: {
                            TAG: "AtomVar",
                            _0: "x"
                          }
                        }
                      }
                    });
                expect(llvm).toContain("alloca { i64, i64, i64 }");
                expect(llvm).toContain("getelementptr");
                expect(llvm).toContain("load i64");
              }));
        test("tuple with variables", (function () {
                var llvm = Compile.LLVMLowering.lowerPhase3({
                      TAG: "Bop",
                      _0: "a",
                      _1: "Plus",
                      _2: {
                        TAG: "AtomInt",
                        _0: 5
                      },
                      _3: {
                        TAG: "AtomInt",
                        _0: 3
                      },
                      _4: {
                        TAG: "Bop",
                        _0: "b",
                        _1: "Plus",
                        _2: {
                          TAG: "AtomInt",
                          _0: 10
                        },
                        _3: {
                          TAG: "AtomInt",
                          _0: 2
                        },
                        _4: {
                          TAG: "Tuple",
                          _0: "t",
                          _1: {
                            hd: {
                              TAG: "AtomVar",
                              _0: "a"
                            },
                            tl: {
                              hd: {
                                TAG: "AtomVar",
                                _0: "b"
                              },
                              tl: {
                                hd: {
                                  TAG: "AtomInt",
                                  _0: 100
                                },
                                tl: /* [] */0
                              }
                            }
                          },
                          _2: {
                            TAG: "Proj",
                            _0: "result",
                            _1: "t",
                            _2: 0,
                            _3: {
                              TAG: "Halt",
                              _0: {
                                TAG: "AtomVar",
                                _0: "result"
                              }
                            }
                          }
                        }
                      }
                    });
                expect(llvm).toContain("add i64 5, 3");
                expect(llvm).toContain("add i64 10, 2");
                expect(llvm).toContain("alloca { i64, i64, i64 }");
              }));
        test("multiple projections from same tuple", (function () {
                var llvm = Compile.LLVMLowering.lowerPhase3({
                      TAG: "Tuple",
                      _0: "t",
                      _1: {
                        hd: {
                          TAG: "AtomInt",
                          _0: 1
                        },
                        tl: {
                          hd: {
                            TAG: "AtomInt",
                            _0: 2
                          },
                          tl: {
                            hd: {
                              TAG: "AtomInt",
                              _0: 3
                            },
                            tl: /* [] */0
                          }
                        }
                      },
                      _2: {
                        TAG: "Proj",
                        _0: "x",
                        _1: "t",
                        _2: 0,
                        _3: {
                          TAG: "Proj",
                          _0: "y",
                          _1: "t",
                          _2: 2,
                          _3: {
                            TAG: "Bop",
                            _0: "sum",
                            _1: "Plus",
                            _2: {
                              TAG: "AtomVar",
                              _0: "x"
                            },
                            _3: {
                              TAG: "AtomVar",
                              _0: "y"
                            },
                            _4: {
                              TAG: "Halt",
                              _0: {
                                TAG: "AtomVar",
                                _0: "sum"
                              }
                            }
                          }
                        }
                      }
                    });
                expect(llvm).toContain("add i64 %x, %y");
              }));
      }));

describe("LLVM Lowering Phase 4", (function () {
        test("simple if statement", (function () {
                var llvm = Compile.LLVMLowering.lowerPhase4({
                      TAG: "If",
                      _0: {
                        TAG: "AtomInt",
                        _0: 1
                      },
                      _1: {
                        TAG: "Halt",
                        _0: {
                          TAG: "AtomInt",
                          _0: 10
                        }
                      },
                      _2: {
                        TAG: "Halt",
                        _0: {
                          TAG: "AtomInt",
                          _0: 20
                        }
                      }
                    });
                expect(llvm).toContain("icmp ne i64 1, 0");
                expect(llvm).toContain("br i1 %cond");
                expect(llvm).toContain("then1:");
                expect(llvm).toContain("else2:");
              }));
        test("if with computation", (function () {
                var llvm = Compile.LLVMLowering.lowerPhase4({
                      TAG: "Bop",
                      _0: "x",
                      _1: "Plus",
                      _2: {
                        TAG: "AtomInt",
                        _0: 5
                      },
                      _3: {
                        TAG: "AtomInt",
                        _0: 3
                      },
                      _4: {
                        TAG: "If",
                        _0: {
                          TAG: "AtomVar",
                          _0: "x"
                        },
                        _1: {
                          TAG: "Bop",
                          _0: "result1",
                          _1: "Plus",
                          _2: {
                            TAG: "AtomVar",
                            _0: "x"
                          },
                          _3: {
                            TAG: "AtomInt",
                            _0: 10
                          },
                          _4: {
                            TAG: "Halt",
                            _0: {
                              TAG: "AtomVar",
                              _0: "result1"
                            }
                          }
                        },
                        _2: {
                          TAG: "Bop",
                          _0: "result2",
                          _1: "Minus",
                          _2: {
                            TAG: "AtomVar",
                            _0: "x"
                          },
                          _3: {
                            TAG: "AtomInt",
                            _0: 5
                          },
                          _4: {
                            TAG: "Halt",
                            _0: {
                              TAG: "AtomVar",
                              _0: "result2"
                            }
                          }
                        }
                      }
                    });
                expect(llvm).toContain("add i64 5, 3");
                expect(llvm).toContain("icmp ne i64 %x, 0");
              }));
        test("nested if statements", (function () {
                var llvm = Compile.LLVMLowering.lowerPhase4({
                      TAG: "If",
                      _0: {
                        TAG: "AtomInt",
                        _0: 1
                      },
                      _1: {
                        TAG: "If",
                        _0: {
                          TAG: "AtomInt",
                          _0: 1
                        },
                        _1: {
                          TAG: "Halt",
                          _0: {
                            TAG: "AtomInt",
                            _0: 100
                          }
                        },
                        _2: {
                          TAG: "Halt",
                          _0: {
                            TAG: "AtomInt",
                            _0: 200
                          }
                        }
                      },
                      _2: {
                        TAG: "Halt",
                        _0: {
                          TAG: "AtomInt",
                          _0: 300
                        }
                      }
                    });
                expect(llvm).toContain("then1:");
                expect(llvm).toContain("else2:");
                expect(llvm).toContain("then3:");
                expect(llvm).toContain("else4:");
              }));
      }));

describe("Complete Compilation Pipeline", (function () {
        test("identity function compiles to proper ANF", (function () {
                var compiled = Compile.Compiler.compile(testLambda);
                var printed = ANF.printANF(compiled);
                expect(printed).toContain("fun");
                expect(printed).toContain("env");
                expect(printed).toContain("halt");
              }));
        test("application produces function call structure", (function () {
                var compiled = Compile.Compiler.compile(testApp);
                var printed = ANF.printANF(compiled);
                expect(printed).toContain("fun");
                expect(printed).toContain("let");
                expect(printed).toContain("42");
                expect(printed).toContain("@");
              }));
        test("binary operation compiles to arithmetic", (function () {
                var compiled = Compile.Compiler.compile(testBop);
                var printed = ANF.printANF(compiled);
                expect(printed).toContain("3 + 4");
                expect(printed).toContain("halt");
              }));
        test("if expression compiles to straightline code (hoisting eliminates join points)", (function () {
                var compiled = Compile.Compiler.compile(testIf);
                var printed = ANF.printANF(compiled);
                expect(printed).toContain("if");
                expect(printed).not.toContain("join");
                expect(printed).not.toContain("jump");
              }));
        test("nested functions maintain proper structure", (function () {
                var compiled = Compile.Compiler.compile(testNested);
                var printed = ANF.printANF(compiled);
                var funCount = printed.split("fun ").length - 1 | 0;
                expect(funCount).toBeGreaterThan(1.0);
                expect(printed).toContain("env");
              }));
        test("curried function preserves currying", (function () {
                var compiled = Compile.Compiler.compile(testCurried);
                var printed = ANF.printANF(compiled);
                expect(printed).toContain("fun");
                expect(printed).toContain("+");
                expect(printed).toContain("env");
              }));
        test("complex free variables handled correctly", (function () {
                var compiled = Compile.Compiler.compile(testComplexFreeVars);
                var printed = ANF.printANF(compiled);
                expect(printed).toContain("fun");
                expect(printed).toContain("10");
                expect(printed).toContain("env");
              }));
        test("conditional nested functions compile properly (hoisting extracts functions)", (function () {
                var compiled = Compile.Compiler.compile(testConditionalNested);
                var printed = ANF.printANF(compiled);
                expect(printed).toContain("if");
                expect(printed).toContain("fun");
                expect(printed).not.toContain("join");
              }));
      }));

describe("Integrated Compiler Pipeline Tests", (function () {
        test("complete pipeline - simple arithmetic", (function () {
                var llvm = Compile.Compiler.compileToLLVM({
                      TAG: "Bop",
                      _0: "Plus",
                      _1: {
                        TAG: "Int",
                        _0: 10
                      },
                      _2: {
                        TAG: "Int",
                        _0: 5
                      }
                    }, 1);
                expect(llvm).toContain("add i64 10, 5");
                expect(llvm).toContain("define i64 @main()");
              }));
        test("complete pipeline - function call", (function () {
                expect(function () {
                        return Compile.Compiler.compileToLLVM({
                                    TAG: "App",
                                    _0: {
                                      TAG: "Lam",
                                      _0: "x",
                                      _1: {
                                        TAG: "Bop",
                                        _0: "Plus",
                                        _1: {
                                          TAG: "Var",
                                          _0: "x"
                                        },
                                        _2: {
                                          TAG: "Int",
                                          _0: 1
                                        }
                                      }
                                    },
                                    _1: {
                                      TAG: "Int",
                                      _0: 42
                                    }
                                  }, 2);
                      }).toThrow();
              }));
        test("complete pipeline - conditional (now works with corrected hoisting)", (function () {
                var llvm = Compile.Compiler.compileToLLVM({
                      TAG: "If",
                      _0: {
                        TAG: "Int",
                        _0: 1
                      },
                      _1: {
                        TAG: "Bop",
                        _0: "Plus",
                        _1: {
                          TAG: "Int",
                          _0: 10
                        },
                        _2: {
                          TAG: "Int",
                          _0: 5
                        }
                      },
                      _2: {
                        TAG: "Bop",
                        _0: "Minus",
                        _1: {
                          TAG: "Int",
                          _0: 20
                        },
                        _2: {
                          TAG: "Int",
                          _0: 3
                        }
                      }
                    }, 4);
                expect(llvm).toContain("icmp ne i64 1, 0");
                expect(llvm).toContain("define i64 @main()");
              }));
        test("complete pipeline - conditional (now works with corrected hoisting)", (function () {
                var testApp = Parser.parse("((λx.x + 8) (12 - 5))");
                var llvm = Compile.Compiler.compileToLLVM(testApp, 3);
                console.log(llvm);
                expect(llvm).toContain("inttoptr i64");
                expect(llvm).toContain("getelementptr");
              }));
      }));

describe("Print Functions", (function () {
        test("print lambda expressions with proper syntax", (function () {
                var printed = Ast.printLam(testLambda);
                expect(printed).toContain("λ");
                expect(printed).toContain("x");
                expect(printed).toContain(".");
              }));
        test("print complex lambda expressions", (function () {
                var printed = Ast.printLam(testBop);
                expect(printed).toContain("(");
                expect(printed).toContain(")");
                expect(printed).toContain("3");
                expect(printed).toContain("4");
                expect(printed).toContain("+");
              }));
        test("print ANF halt expressions", (function () {
                var printed = ANF.printANF({
                      TAG: "Halt",
                      _0: {
                        TAG: "AtomInt",
                        _0: 42
                      }
                    });
                expect(printed).toBe("halt 42");
              }));
        test("print ANF binary operations", (function () {
                var printed = ANF.printANF({
                      TAG: "Bop",
                      _0: "r",
                      _1: "Plus",
                      _2: {
                        TAG: "AtomInt",
                        _0: 3
                      },
                      _3: {
                        TAG: "AtomInt",
                        _0: 4
                      },
                      _4: {
                        TAG: "Halt",
                        _0: {
                          TAG: "AtomVar",
                          _0: "r"
                        }
                      }
                    });
                expect(printed).toContain("let r = 3 + 4 in");
                expect(printed).toContain("halt r");
              }));
        test("print atoms correctly", (function () {
                var atomInt = ANF.printAtom({
                      TAG: "AtomInt",
                      _0: 42
                    });
                expect(atomInt).toBe("42");
                var atomVar = ANF.printAtom({
                      TAG: "AtomVar",
                      _0: "x"
                    });
                expect(atomVar).toBe("x");
                var atomGlob = ANF.printAtom({
                      TAG: "AtomGlob",
                      _0: "f"
                    });
                expect(atomGlob).toBe("@f");
              }));
        test("print if expressions", (function () {
                var printed = Ast.printLam(testIf);
                expect(printed).toContain("if 1 then 2 else 3");
              }));
      }));

export {
  testLambda ,
  testApp ,
  testBop ,
  testIf ,
  testNested ,
  testCurried ,
  testComplexFreeVars ,
  testConditionalNested ,
}
/*  Not a pure module */
