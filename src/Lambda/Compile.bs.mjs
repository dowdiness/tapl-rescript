// Generated by ReScript, PLEASE EDIT WITH CARE

import * as ANF from "./ANF.bs.mjs";
import * as Ast from "./Ast.bs.mjs";
import * as Core__List from "@rescript/core/src/Core__List.bs.mjs";
import * as Core__Array from "@rescript/core/src/Core__Array.bs.mjs";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.mjs";
import * as Belt_MapString from "rescript/lib/es6/belt_MapString.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as ClosureConversion from "./ClosureConversion.bs.mjs";

var NotFoundJointPoint = /* @__PURE__ */Caml_exceptions.create("Compile.Hoisting.NotFoundJointPoint");

function substituteVar(term, $$var, replacement) {
  var substAtom = function (atom) {
    switch (atom.TAG) {
      case "AtomVar" :
          if (atom._0 === $$var) {
            return replacement;
          } else {
            return atom;
          }
      case "AtomInt" :
      case "AtomGlob" :
          return atom;
      
    }
  };
  switch (term.TAG) {
    case "Halt" :
        return {
                TAG: "Halt",
                _0: substAtom(term._0)
              };
    case "Fun" :
        var cont = term._3;
        var body = term._2;
        var params = term._1;
        var f = term._0;
        if (Core__List.some(params, (function (p) {
                  return p === $$var;
                })) || f === $$var) {
          return {
                  TAG: "Fun",
                  _0: f,
                  _1: params,
                  _2: body,
                  _3: substituteVar(cont, $$var, replacement)
                };
        } else {
          return {
                  TAG: "Fun",
                  _0: f,
                  _1: params,
                  _2: substituteVar(body, $$var, replacement),
                  _3: substituteVar(cont, $$var, replacement)
                };
        }
    case "Join" :
        return {
                TAG: "Join",
                _0: term._0,
                _1: term._1,
                _2: substituteVar(term._2, $$var, replacement),
                _3: substituteVar(term._3, $$var, replacement)
              };
    case "Jump" :
        return {
                TAG: "Jump",
                _0: term._0,
                _1: Core__Option.map(term._1, substAtom)
              };
    case "App" :
        var f$1 = term._1;
        var newArgs = Core__List.map(term._2, substAtom);
        var newF;
        if (f$1 === $$var) {
          switch (replacement.TAG) {
            case "AtomVar" :
                newF = replacement._0;
                break;
            case "AtomInt" :
            case "AtomGlob" :
                newF = f$1;
                break;
            
          }
        } else {
          newF = f$1;
        }
        return {
                TAG: "App",
                _0: term._0,
                _1: newF,
                _2: newArgs,
                _3: substituteVar(term._3, $$var, replacement)
              };
    case "Bop" :
        return {
                TAG: "Bop",
                _0: term._0,
                _1: term._1,
                _2: substAtom(term._2),
                _3: substAtom(term._3),
                _4: substituteVar(term._4, $$var, replacement)
              };
    case "If" :
        return {
                TAG: "If",
                _0: substAtom(term._0),
                _1: substituteVar(term._1, $$var, replacement),
                _2: substituteVar(term._2, $$var, replacement)
              };
    case "Tuple" :
        return {
                TAG: "Tuple",
                _0: term._0,
                _1: Core__List.map(term._1, substAtom),
                _2: substituteVar(term._2, $$var, replacement)
              };
    case "Proj" :
        var x = term._1;
        var newX;
        if (x === $$var) {
          switch (replacement.TAG) {
            case "AtomVar" :
                newX = replacement._0;
                break;
            case "AtomInt" :
            case "AtomGlob" :
                newX = x;
                break;
            
          }
        } else {
          newX = x;
        }
        return {
                TAG: "Proj",
                _0: term._0,
                _1: newX,
                _2: term._2,
                _3: substituteVar(term._3, $$var, replacement)
              };
    
  }
}

function collectJoinPoints(term) {
  var joinPoints = {
    contents: undefined
  };
  var collect = function (_t) {
    while(true) {
      var t = _t;
      switch (t.TAG) {
        case "Fun" :
            collect(t._2);
            _t = t._3;
            continue ;
        case "Join" :
            var body = t._2;
            var j = t._0;
            var jp_param = t._1;
            var jp = {
              name: j,
              param: jp_param,
              body: body
            };
            joinPoints.contents = Belt_MapString.set(joinPoints.contents, j, jp);
            collect(body);
            _t = t._3;
            continue ;
        case "Halt" :
        case "Jump" :
            return ;
        case "Bop" :
            _t = t._4;
            continue ;
        case "If" :
            collect(t._1);
            _t = t._2;
            continue ;
        case "Tuple" :
            _t = t._2;
            continue ;
        case "App" :
        case "Proj" :
            _t = t._3;
            continue ;
        
      }
    };
  };
  collect(term);
  return joinPoints.contents;
}

function eliminateJoinPoints(term) {
  var joinPoints = collectJoinPoints(term);
  var eliminate = function (_t) {
    while(true) {
      var t = _t;
      switch (t.TAG) {
        case "Halt" :
            return t;
        case "Fun" :
            return {
                    TAG: "Fun",
                    _0: t._0,
                    _1: t._1,
                    _2: eliminate(t._2),
                    _3: eliminate(t._3)
                  };
        case "Join" :
            _t = t._3;
            continue ;
        case "Jump" :
            var arg = t._1;
            var match = Belt_MapString.get(joinPoints, t._0);
            if (match !== undefined) {
              var p = match.param;
              if (p !== undefined) {
                var body = match.body;
                if (arg !== undefined) {
                  _t = substituteVar(body, p, arg);
                  continue ;
                }
                _t = body;
                continue ;
              }
              _t = match.body;
              continue ;
            }
            throw {
                  RE_EXN_ID: NotFoundJointPoint,
                  _1: t,
                  Error: new Error()
                };
        case "App" :
            return {
                    TAG: "App",
                    _0: t._0,
                    _1: t._1,
                    _2: t._2,
                    _3: eliminate(t._3)
                  };
        case "Bop" :
            return {
                    TAG: "Bop",
                    _0: t._0,
                    _1: t._1,
                    _2: t._2,
                    _3: t._3,
                    _4: eliminate(t._4)
                  };
        case "If" :
            return {
                    TAG: "If",
                    _0: t._0,
                    _1: eliminate(t._1),
                    _2: eliminate(t._2)
                  };
        case "Tuple" :
            return {
                    TAG: "Tuple",
                    _0: t._0,
                    _1: t._1,
                    _2: eliminate(t._2)
                  };
        case "Proj" :
            return {
                    TAG: "Proj",
                    _0: t._0,
                    _1: t._1,
                    _2: t._2,
                    _3: eliminate(t._3)
                  };
        
      }
    };
  };
  return eliminate(term);
}

function extractFunctions(term) {
  var functions = {
    contents: /* [] */0
  };
  var extract = function (_t) {
    while(true) {
      var t = _t;
      switch (t.TAG) {
        case "Fun" :
            var hoistedBody = extract(t._2);
            functions.contents = {
              hd: [
                t._0,
                t._1,
                hoistedBody
              ],
              tl: functions.contents
            };
            _t = t._3;
            continue ;
        case "Join" :
            return {
                    TAG: "Join",
                    _0: t._0,
                    _1: t._1,
                    _2: extract(t._2),
                    _3: extract(t._3)
                  };
        case "Halt" :
        case "Jump" :
            return t;
        case "App" :
            return {
                    TAG: "App",
                    _0: t._0,
                    _1: t._1,
                    _2: t._2,
                    _3: extract(t._3)
                  };
        case "Bop" :
            return {
                    TAG: "Bop",
                    _0: t._0,
                    _1: t._1,
                    _2: t._2,
                    _3: t._3,
                    _4: extract(t._4)
                  };
        case "If" :
            return {
                    TAG: "If",
                    _0: t._0,
                    _1: extract(t._1),
                    _2: extract(t._2)
                  };
        case "Tuple" :
            return {
                    TAG: "Tuple",
                    _0: t._0,
                    _1: t._1,
                    _2: extract(t._2)
                  };
        case "Proj" :
            return {
                    TAG: "Proj",
                    _0: t._0,
                    _1: t._1,
                    _2: t._2,
                    _3: extract(t._3)
                  };
        
      }
    };
  };
  var mainFlow = extract(term);
  return [
          Core__List.reverse(functions.contents),
          mainFlow
        ];
}

function reconstructWithFunctions(functions, mainFlow) {
  var reconstruct = function (funcs, acc) {
    if (!funcs) {
      return acc;
    }
    var match = funcs.hd;
    return {
            TAG: "Fun",
            _0: match[0],
            _1: match[1],
            _2: match[2],
            _3: reconstruct(funcs.tl, acc)
          };
  };
  return reconstruct(functions, mainFlow);
}

function hoist(term) {
  var param = extractFunctions(eliminateJoinPoints(term));
  return reconstructWithFunctions(param[0], param[1]);
}

var Hoisting = {
  NotFoundJointPoint: NotFoundJointPoint,
  substituteVar: substituteVar,
  collectJoinPoints: collectJoinPoints,
  eliminateJoinPoints: eliminateJoinPoints,
  extractFunctions: extractFunctions,
  reconstructWithFunctions: reconstructWithFunctions,
  hoist: hoist
};

function atomToLLVM(atom) {
  switch (atom.TAG) {
    case "AtomInt" :
        return atom._0.toString();
    case "AtomVar" :
        return "%" + atom._0;
    case "AtomGlob" :
        return "@" + atom._0;
    
  }
}

function atomToTypedLLVM(atom) {
  return "i64 " + atomToLLVM(atom);
}

function bopToLLVM(r, bop, x, y) {
  var x$1 = atomToLLVM(x);
  var y$1 = atomToLLVM(y);
  if (bop === "Plus") {
    return "%" + r + " = add i64 " + x$1 + ", " + y$1;
  } else {
    return "%" + r + " = sub i64 " + x$1 + ", " + y$1;
  }
}

function lowerPhase1(anf) {
  var go = function (_t, _insts) {
    while(true) {
      var insts = _insts;
      var t = _t;
      switch (t.TAG) {
        case "Halt" :
            var n = t._0;
            switch (n.TAG) {
              case "AtomInt" :
                  return Core__List.add(insts, "ret i64 " + n._0.toString());
              case "AtomVar" :
                  return Core__List.add(insts, "ret i64 %" + n._0);
              case "AtomGlob" :
                  return PervasivesU.failwith("Phase 1: Unsupported ANF construct");
              
            }
        case "Bop" :
            _insts = Core__List.add(insts, bopToLLVM(t._0, t._1, t._2, t._3));
            _t = t._4;
            continue ;
        default:
          return PervasivesU.failwith("Phase 1: Unsupported ANF construct");
      }
    };
  };
  var insts = go(anf, /* [] */0);
  var body = Core__List.toArray(Core__List.reverse(insts)).join("\n  ");
  return "define i64 @main() {\nentry:\n  " + body + "\n}";
}

function lowerPhase2(anf) {
  var functions = {
    contents: /* [] */0
  };
  var mainInstructions = {
    contents: /* [] */0
  };
  var extractFunctions = function (_t) {
    while(true) {
      var t = _t;
      switch (t.TAG) {
        case "Halt" :
            var x = t._0;
            switch (x.TAG) {
              case "AtomInt" :
                  mainInstructions.contents = {
                    hd: "ret i64 " + x._0.toString(),
                    tl: mainInstructions.contents
                  };
                  return ;
              case "AtomVar" :
                  var x$1 = x._0;
                  var isFunctionName = Core__List.some(functions.contents, (function(x$1){
                      return function (funcDef) {
                        return funcDef.includes("@" + x$1 + "(");
                      }
                      }(x$1)));
                  if (isFunctionName) {
                    return PervasivesU.failwith("Phase 2: Function references not yet supported: " + x$1);
                  } else {
                    mainInstructions.contents = {
                      hd: "ret i64 %" + x$1,
                      tl: mainInstructions.contents
                    };
                    return ;
                  }
              case "AtomGlob" :
                  return PervasivesU.failwith("Phase 2: Unsupported ANF construct");
              
            }
        case "Fun" :
            var paramList = Core__List.toArray(Core__List.map(t._1, (function (p) {
                          return "i64 %" + p;
                        }))).join(", ");
            var bodyInstructions = {
              contents: /* [] */0
            };
            var generateBody = (function(bodyInstructions){
            return function generateBody(_bodyTerm) {
              while(true) {
                var bodyTerm = _bodyTerm;
                switch (bodyTerm.TAG) {
                  case "Halt" :
                      var n = bodyTerm._0;
                      switch (n.TAG) {
                        case "AtomInt" :
                            bodyInstructions.contents = {
                              hd: "ret i64 " + n._0.toString(),
                              tl: bodyInstructions.contents
                            };
                            return ;
                        case "AtomVar" :
                            bodyInstructions.contents = {
                              hd: "ret i64 %" + n._0,
                              tl: bodyInstructions.contents
                            };
                            return ;
                        case "AtomGlob" :
                            return PervasivesU.failwith("Phase 2: Unsupported construct in function body");
                        
                      }
                  case "Bop" :
                      var r = bodyTerm._0;
                      if (bodyTerm._1 === "Plus") {
                        bodyInstructions.contents = {
                          hd: "%" + r + " = add i64 " + atomToLLVM(bodyTerm._2) + ", " + atomToLLVM(bodyTerm._3),
                          tl: bodyInstructions.contents
                        };
                        _bodyTerm = bodyTerm._4;
                        continue ;
                      }
                      bodyInstructions.contents = {
                        hd: "%" + r + " = sub i64 " + atomToLLVM(bodyTerm._2) + ", " + atomToLLVM(bodyTerm._3),
                        tl: bodyInstructions.contents
                      };
                      _bodyTerm = bodyTerm._4;
                      continue ;
                  default:
                    return PervasivesU.failwith("Phase 2: Unsupported construct in function body");
                }
              };
            }
            }(bodyInstructions));
            generateBody(t._2);
            var bodyStr = Core__List.toArray(Core__List.reverse(bodyInstructions.contents)).join("\n  ");
            var funcDef = "define i64 @" + t._0 + "(" + paramList + ") {\nentry:\n  " + bodyStr + "\n}";
            functions.contents = {
              hd: funcDef,
              tl: functions.contents
            };
            _t = t._3;
            continue ;
        case "App" :
            var argList = Core__List.toArray(Core__List.map(t._2, atomToTypedLLVM)).join(", ");
            mainInstructions.contents = {
              hd: "%" + t._0 + " = call i64 @" + t._1 + "(" + argList + ")",
              tl: mainInstructions.contents
            };
            _t = t._3;
            continue ;
        case "Bop" :
            var r = t._0;
            if (t._1 === "Plus") {
              mainInstructions.contents = {
                hd: "%" + r + " = add i64 " + atomToLLVM(t._2) + ", " + atomToLLVM(t._3),
                tl: mainInstructions.contents
              };
              _t = t._4;
              continue ;
            }
            mainInstructions.contents = {
              hd: "%" + r + " = sub i64 " + atomToLLVM(t._2) + ", " + atomToLLVM(t._3),
              tl: mainInstructions.contents
            };
            _t = t._4;
            continue ;
        default:
          return PervasivesU.failwith("Phase 2: Unsupported ANF construct");
      }
    };
  };
  extractFunctions(anf);
  var functionsStr = Core__List.toArray(Core__List.reverse(functions.contents)).join("\n\n");
  var mainBody = Core__List.toArray(Core__List.reverse(mainInstructions.contents)).join("\n  ");
  var mainFunc = "define i64 @main() {\nentry:\n  " + mainBody + "\n}";
  if (Core__List.length(functions.contents) > 0) {
    return functionsStr + "\n\n" + mainFunc;
  } else {
    return mainFunc;
  }
}

function lowerPhase3(anf) {
  var functions = {
    contents: /* [] */0
  };
  var mainInstructions = {
    contents: /* [] */0
  };
  var extractFunctions = function (_t) {
    while(true) {
      var t = _t;
      switch (t.TAG) {
        case "Halt" :
            var x = t._0;
            switch (x.TAG) {
              case "AtomInt" :
                  mainInstructions.contents = {
                    hd: "ret i64 " + x._0.toString(),
                    tl: mainInstructions.contents
                  };
                  return ;
              case "AtomVar" :
                  var x$1 = x._0;
                  var isFunctionName = Core__List.some(functions.contents, (function(x$1){
                      return function (funcDef) {
                        return funcDef.includes("@" + x$1 + "(");
                      }
                      }(x$1)));
                  if (isFunctionName) {
                    return PervasivesU.failwith("Phase 3: Function references not yet supported: " + x$1);
                  } else {
                    mainInstructions.contents = {
                      hd: "ret i64 %" + x$1,
                      tl: mainInstructions.contents
                    };
                    return ;
                  }
              case "AtomGlob" :
                  return PervasivesU.failwith("Phase 3: Unsupported ANF construct");
              
            }
        case "Fun" :
            var paramList = Core__List.toArray(Core__List.map(t._1, (function (p) {
                          return "i64 %" + p;
                        }))).join(", ");
            var bodyInstructions = {
              contents: /* [] */0
            };
            var generateBody = (function(bodyInstructions){
            return function generateBody(_bodyTerm) {
              while(true) {
                var bodyTerm = _bodyTerm;
                switch (bodyTerm.TAG) {
                  case "Halt" :
                      var n = bodyTerm._0;
                      switch (n.TAG) {
                        case "AtomInt" :
                            bodyInstructions.contents = {
                              hd: "ret i64 " + n._0.toString(),
                              tl: bodyInstructions.contents
                            };
                            return ;
                        case "AtomVar" :
                            bodyInstructions.contents = {
                              hd: "ret i64 %" + n._0,
                              tl: bodyInstructions.contents
                            };
                            return ;
                        case "AtomGlob" :
                            return PervasivesU.failwith("Phase 3: Unsupported construct in function body");
                        
                      }
                  case "Bop" :
                      var r = bodyTerm._0;
                      if (bodyTerm._1 === "Plus") {
                        bodyInstructions.contents = {
                          hd: "%" + r + " = add i64 " + atomToLLVM(bodyTerm._2) + ", " + atomToLLVM(bodyTerm._3),
                          tl: bodyInstructions.contents
                        };
                        _bodyTerm = bodyTerm._4;
                        continue ;
                      }
                      bodyInstructions.contents = {
                        hd: "%" + r + " = sub i64 " + atomToLLVM(bodyTerm._2) + ", " + atomToLLVM(bodyTerm._3),
                        tl: bodyInstructions.contents
                      };
                      _bodyTerm = bodyTerm._4;
                      continue ;
                  case "Tuple" :
                      var vs = bodyTerm._1;
                      var r$1 = bodyTerm._0;
                      var size = Core__List.length(vs);
                      bodyInstructions.contents = {
                        hd: "%" + r$1 + "_ptr = alloca { " + Core__Array.make(size, "i64").join(", ") + " }",
                        tl: bodyInstructions.contents
                      };
                      Core__List.mapWithIndex(vs, (function(r$1,size){
                          return function (atom, i) {
                            var gepInstr = "%" + r$1 + "_gep" + i.toString() + " = getelementptr { " + Core__Array.make(size, "i64").join(", ") + " }, { " + Core__Array.make(size, "i64").join(", ") + " }* %" + r$1 + "_ptr, i32 0, i32 " + i.toString();
                            var storeInstr;
                            var exit = 0;
                            switch (atom.TAG) {
                              case "AtomInt" :
                              case "AtomVar" :
                                  exit = 1;
                                  break;
                              case "AtomGlob" :
                                  var tmpVar = r$1 + "_tmp" + i.toString();
                                  bodyInstructions.contents = {
                                    hd: "%" + tmpVar + " = ptrtoint i64 (i64, i64)* @" + atom._0 + " to i64",
                                    tl: bodyInstructions.contents
                                  };
                                  storeInstr = "store i64 %" + tmpVar + ", i64* %" + r$1 + "_gep" + i.toString();
                                  break;
                              
                            }
                            if (exit === 1) {
                              storeInstr = "store i64 " + atomToLLVM(atom) + ", i64* %" + r$1 + "_gep" + i.toString();
                            }
                            bodyInstructions.contents = {
                              hd: storeInstr,
                              tl: {
                                hd: gepInstr,
                                tl: bodyInstructions.contents
                              }
                            };
                          }
                          }(r$1,size)));
                      bodyInstructions.contents = {
                        hd: "%" + r$1 + " = ptrtoint { " + Core__Array.make(size, "i64").join(", ") + " }* %" + r$1 + "_ptr to i64",
                        tl: bodyInstructions.contents
                      };
                      _bodyTerm = bodyTerm._2;
                      continue ;
                  case "Proj" :
                      var x = bodyTerm._1;
                      var r$2 = bodyTerm._0;
                      var ptrVar = x + "_ptr_" + r$2;
                      var gepVar = r$2 + "_gep";
                      bodyInstructions.contents = {
                        hd: "%" + ptrVar + " = inttoptr i64 %" + x + " to { i64, i64, i64 }*",
                        tl: bodyInstructions.contents
                      };
                      bodyInstructions.contents = {
                        hd: "%" + gepVar + " = getelementptr { i64, i64, i64 }, { i64, i64, i64 }* %" + ptrVar + ", i32 0, i32 " + bodyTerm._2.toString(),
                        tl: bodyInstructions.contents
                      };
                      bodyInstructions.contents = {
                        hd: "%" + r$2 + " = load i64, i64* %" + gepVar,
                        tl: bodyInstructions.contents
                      };
                      _bodyTerm = bodyTerm._3;
                      continue ;
                  default:
                    return PervasivesU.failwith("Phase 3: Unsupported construct in function body");
                }
              };
            }
            }(bodyInstructions));
            generateBody(t._2);
            var bodyStr = Core__List.toArray(Core__List.reverse(bodyInstructions.contents)).join("\n  ");
            var funcDef = "define i64 @" + t._0 + "(" + paramList + ") {\nentry:\n  " + bodyStr + "\n}";
            functions.contents = {
              hd: funcDef,
              tl: functions.contents
            };
            _t = t._3;
            continue ;
        case "App" :
            var f = t._1;
            var argList = Core__List.toArray(Core__List.map(t._2, (function (atom) {
                          switch (atom.TAG) {
                            case "AtomInt" :
                                return "i64 " + atom._0.toString();
                            case "AtomVar" :
                                return "i64 %" + atom._0;
                            case "AtomGlob" :
                                return "i64 @" + atom._0;
                            
                          }
                        }))).join(", ");
            var fptrVar = f + "_fptr";
            mainInstructions.contents = {
              hd: "%" + fptrVar + " = inttoptr i64 %" + f + " to i64 (i64, i64)*",
              tl: mainInstructions.contents
            };
            mainInstructions.contents = {
              hd: "%" + t._0 + " = call i64 %" + fptrVar + "(" + argList + ")",
              tl: mainInstructions.contents
            };
            _t = t._3;
            continue ;
        case "Bop" :
            var r = t._0;
            if (t._1 === "Plus") {
              mainInstructions.contents = {
                hd: "%" + r + " = add i64 " + atomToLLVM(t._2) + ", " + atomToLLVM(t._3),
                tl: mainInstructions.contents
              };
              _t = t._4;
              continue ;
            }
            mainInstructions.contents = {
              hd: "%" + r + " = sub i64 " + atomToLLVM(t._2) + ", " + atomToLLVM(t._3),
              tl: mainInstructions.contents
            };
            _t = t._4;
            continue ;
        case "Tuple" :
            var vs = t._1;
            var r$1 = t._0;
            var size = Core__List.length(vs);
            mainInstructions.contents = {
              hd: "%" + r$1 + "_ptr = alloca { " + Core__Array.make(size, "i64").join(", ") + " }",
              tl: mainInstructions.contents
            };
            Core__List.mapWithIndex(vs, (function(r$1,size){
                return function (atom, i) {
                  var gepInstr = "%" + r$1 + "_gep" + i.toString() + " = getelementptr { " + Core__Array.make(size, "i64").join(", ") + " }, { " + Core__Array.make(size, "i64").join(", ") + " }* %" + r$1 + "_ptr, i32 0, i32 " + i.toString();
                  var storeInstr;
                  var exit = 0;
                  switch (atom.TAG) {
                    case "AtomInt" :
                    case "AtomVar" :
                        exit = 1;
                        break;
                    case "AtomGlob" :
                        var tmpVar = r$1 + "_tmp" + i.toString();
                        mainInstructions.contents = {
                          hd: "%" + tmpVar + " = ptrtoint i64 (i64, i64)* @" + atom._0 + " to i64",
                          tl: mainInstructions.contents
                        };
                        storeInstr = "store i64 %" + tmpVar + ", i64* %" + r$1 + "_gep" + i.toString();
                        break;
                    
                  }
                  if (exit === 1) {
                    storeInstr = "store i64 " + atomToLLVM(atom) + ", i64* %" + r$1 + "_gep" + i.toString();
                  }
                  mainInstructions.contents = {
                    hd: storeInstr,
                    tl: {
                      hd: gepInstr,
                      tl: mainInstructions.contents
                    }
                  };
                }
                }(r$1,size)));
            mainInstructions.contents = {
              hd: "%" + r$1 + " = ptrtoint { " + Core__Array.make(size, "i64").join(", ") + " }* %" + r$1 + "_ptr to i64",
              tl: mainInstructions.contents
            };
            _t = t._2;
            continue ;
        case "Proj" :
            var x$2 = t._1;
            var r$2 = t._0;
            var ptrVar = x$2 + "_ptr_" + r$2;
            var gepVar = r$2 + "_gep";
            mainInstructions.contents = {
              hd: "%" + ptrVar + " = inttoptr i64 %" + x$2 + " to { i64, i64, i64 }*",
              tl: mainInstructions.contents
            };
            mainInstructions.contents = {
              hd: "%" + gepVar + " = getelementptr { i64, i64, i64 }, { i64, i64, i64 }* %" + ptrVar + ", i32 0, i32 " + t._2.toString(),
              tl: mainInstructions.contents
            };
            mainInstructions.contents = {
              hd: "%" + r$2 + " = load i64, i64* %" + gepVar,
              tl: mainInstructions.contents
            };
            _t = t._3;
            continue ;
        default:
          return PervasivesU.failwith("Phase 3: Unsupported ANF construct");
      }
    };
  };
  extractFunctions(anf);
  var functionsStr = Core__List.toArray(Core__List.reverse(functions.contents)).join("\n\n");
  var mainBody = Core__List.toArray(Core__List.reverse(mainInstructions.contents)).join("\n  ");
  var mainFunc = "define i64 @main() {\nentry:\n  " + mainBody + "\n}";
  if (Core__List.length(functions.contents) > 0) {
    return functionsStr + "\n\n" + mainFunc;
  } else {
    return mainFunc;
  }
}

function lowerPhase4(anf) {
  var functions = {
    contents: /* [] */0
  };
  var mainInstructions = {
    contents: /* [] */0
  };
  var labelCounter = {
    contents: 0
  };
  var getNextLabel = function (prefix) {
    labelCounter.contents = labelCounter.contents + 1 | 0;
    return prefix + labelCounter.contents.toString();
  };
  var extractFunctions = function (_t) {
    while(true) {
      var t = _t;
      switch (t.TAG) {
        case "Halt" :
            var x = t._0;
            switch (x.TAG) {
              case "AtomInt" :
                  mainInstructions.contents = {
                    hd: "ret i64 " + x._0.toString(),
                    tl: mainInstructions.contents
                  };
                  return ;
              case "AtomVar" :
                  var x$1 = x._0;
                  var isFunctionName = Core__List.some(functions.contents, (function(x$1){
                      return function (funcDef) {
                        return funcDef.includes("@" + x$1 + "(");
                      }
                      }(x$1)));
                  if (isFunctionName) {
                    return PervasivesU.failwith("Phase 4: Function references not yet supported: " + x$1);
                  } else {
                    mainInstructions.contents = {
                      hd: "ret i64 %" + x$1,
                      tl: mainInstructions.contents
                    };
                    return ;
                  }
              case "AtomGlob" :
                  return PervasivesU.failwith("Phase 4: Unsupported ANF construct");
              
            }
        case "Fun" :
            var paramList = Core__List.toArray(Core__List.map(t._1, (function (p) {
                          return "i64 %" + p;
                        }))).join(", ");
            var bodyInstructions = {
              contents: /* [] */0
            };
            var generateBody = (function(bodyInstructions){
            return function generateBody(_bodyTerm) {
              while(true) {
                var bodyTerm = _bodyTerm;
                switch (bodyTerm.TAG) {
                  case "Halt" :
                      var n = bodyTerm._0;
                      switch (n.TAG) {
                        case "AtomInt" :
                            bodyInstructions.contents = {
                              hd: "ret i64 " + n._0.toString(),
                              tl: bodyInstructions.contents
                            };
                            return ;
                        case "AtomVar" :
                            bodyInstructions.contents = {
                              hd: "ret i64 %" + n._0,
                              tl: bodyInstructions.contents
                            };
                            return ;
                        case "AtomGlob" :
                            break;
                        
                      }
                      break;
                  case "Bop" :
                      var r = bodyTerm._0;
                      if (bodyTerm._1 === "Plus") {
                        bodyInstructions.contents = {
                          hd: "%" + r + " = add i64 " + atomToLLVM(bodyTerm._2) + ", " + atomToLLVM(bodyTerm._3),
                          tl: bodyInstructions.contents
                        };
                        _bodyTerm = bodyTerm._4;
                        continue ;
                      }
                      bodyInstructions.contents = {
                        hd: "%" + r + " = sub i64 " + atomToLLVM(bodyTerm._2) + ", " + atomToLLVM(bodyTerm._3),
                        tl: bodyInstructions.contents
                      };
                      _bodyTerm = bodyTerm._4;
                      continue ;
                  case "If" :
                      var thenLabel = getNextLabel("then");
                      var elseLabel = getNextLabel("else");
                      bodyInstructions.contents = {
                        hd: "%cond = icmp ne i64 " + atomToLLVM(bodyTerm._0) + ", 0",
                        tl: bodyInstructions.contents
                      };
                      bodyInstructions.contents = {
                        hd: "br i1 %cond, label %" + thenLabel + ", label %" + elseLabel,
                        tl: bodyInstructions.contents
                      };
                      bodyInstructions.contents = {
                        hd: thenLabel + ":",
                        tl: bodyInstructions.contents
                      };
                      generateBody(bodyTerm._1);
                      bodyInstructions.contents = {
                        hd: elseLabel + ":",
                        tl: bodyInstructions.contents
                      };
                      _bodyTerm = bodyTerm._2;
                      continue ;
                  default:
                    
                }
                return PervasivesU.failwith("Phase 4: Unsupported construct in function body: " + ANF.printANF(bodyTerm));
              };
            }
            }(bodyInstructions));
            generateBody(t._2);
            var bodyStr = Core__List.toArray(Core__List.reverse(bodyInstructions.contents)).join("\n  ");
            var funcDef = "define i64 @" + t._0 + "(" + paramList + ") {\nentry:\n  " + bodyStr + "\n}";
            functions.contents = {
              hd: funcDef,
              tl: functions.contents
            };
            _t = t._3;
            continue ;
        case "Join" :
            return PervasivesU.failwith("Code must be straightline!");
        case "Jump" :
            if (t._1 !== undefined) {
              return PervasivesU.failwith("Phase 4: Unsupported ANF construct");
            } else {
              mainInstructions.contents = {
                hd: "br label %" + t._0,
                tl: mainInstructions.contents
              };
              return ;
            }
        case "Bop" :
            var r = t._0;
            if (t._1 === "Plus") {
              mainInstructions.contents = {
                hd: "%" + r + " = add i64 " + atomToLLVM(t._2) + ", " + atomToLLVM(t._3),
                tl: mainInstructions.contents
              };
              _t = t._4;
              continue ;
            }
            mainInstructions.contents = {
              hd: "%" + r + " = sub i64 " + atomToLLVM(t._2) + ", " + atomToLLVM(t._3),
              tl: mainInstructions.contents
            };
            _t = t._4;
            continue ;
        case "If" :
            var thenLabel = getNextLabel("then");
            var elseLabel = getNextLabel("else");
            mainInstructions.contents = {
              hd: "%cond = icmp ne i64 " + atomToLLVM(t._0) + ", 0",
              tl: mainInstructions.contents
            };
            mainInstructions.contents = {
              hd: "br i1 %cond, label %" + thenLabel + ", label %" + elseLabel,
              tl: mainInstructions.contents
            };
            mainInstructions.contents = {
              hd: thenLabel + ":",
              tl: mainInstructions.contents
            };
            extractFunctions(t._1);
            mainInstructions.contents = {
              hd: elseLabel + ":",
              tl: mainInstructions.contents
            };
            _t = t._2;
            continue ;
        default:
          return PervasivesU.failwith("Phase 4: Unsupported ANF construct");
      }
    };
  };
  extractFunctions(anf);
  var functionsStr = Core__List.toArray(Core__List.reverse(functions.contents)).join("\n\n");
  var mainBody = Core__List.toArray(Core__List.reverse(mainInstructions.contents)).join("\n  ");
  var mainFunc = "define i64 @main() {\nentry:\n  " + mainBody + "\n}";
  if (Core__List.length(functions.contents) > 0) {
    return functionsStr + "\n\n" + mainFunc;
  } else {
    return mainFunc;
  }
}

var LLVMLowering = {
  atomToLLVM: atomToLLVM,
  atomToTypedLLVM: atomToTypedLLVM,
  bopToLLVM: bopToLLVM,
  lowerPhase1: lowerPhase1,
  lowerPhase2: lowerPhase2,
  lowerPhase3: lowerPhase3,
  lowerPhase4: lowerPhase4
};

function compile(term) {
  return hoist(ClosureConversion.convert(ANF.convert(Ast.rename(term))));
}

function compileToLLVM(term, phase) {
  var anf = compile(term);
  switch (phase) {
    case 1 :
        return lowerPhase1(anf);
    case 2 :
        return lowerPhase2(anf);
    case 3 :
        return lowerPhase3(anf);
    case 4 :
        return lowerPhase4(anf);
    default:
      return PervasivesU.failwith("Unsupported LLVM lowering phase");
  }
}

var Compiler = {
  compile: compile,
  compileToLLVM: compileToLLVM
};

export {
  Hoisting ,
  LLVMLowering ,
  Compiler ,
}
/* ANF Not a pure module */
