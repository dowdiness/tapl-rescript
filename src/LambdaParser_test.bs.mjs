// Generated by ReScript, PLEASE EDIT WITH CARE

import * as LambdaParser from "./LambdaParser.bs.mjs";
import * as LambdaCompile from "./LambdaCompile.bs.mjs";

describe("LambdaParser Tests", (function () {
        test("tokenize simple integer", (function () {
                var tokens = LambdaParser.tokenize("42");
                var tokenStrings = LambdaParser.printTokens(tokens);
                expect(tokenStrings).toContain("42");
                expect(tokenStrings).toContain("EOF");
              }));
        test("tokenize simple variable", (function () {
                var tokens = LambdaParser.tokenize("x");
                var tokenStrings = LambdaParser.printTokens(tokens);
                expect(tokenStrings).toContain("x");
                expect(tokenStrings).toContain("EOF");
              }));
        test("tokenize lambda expression", (function () {
                var tokens = LambdaParser.tokenize("λx.x");
                var tokenStrings = LambdaParser.printTokens(tokens);
                expect(tokenStrings).toContain("λ");
                expect(tokenStrings).toContain("x");
                expect(tokenStrings).toContain(".");
                expect(tokenStrings).toContain("EOF");
              }));
        test("tokenize with backslash lambda", (function () {
                var tokens = LambdaParser.tokenize("\\x.x");
                var tokenStrings = LambdaParser.printTokens(tokens);
                expect(tokenStrings).toContain("λ");
                expect(tokenStrings).toContain("x");
                expect(tokenStrings).toContain(".");
              }));
        test("tokenize plus binary operator", (function () {
                var tokens = LambdaParser.tokenize("1 + 2");
                var tokenStrings = LambdaParser.printTokens(tokens);
                expect(tokenStrings).toContain("1");
                expect(tokenStrings).toContain("+");
                expect(tokenStrings).toContain("2");
                expect(tokenStrings).toContain("EOF");
              }));
        test("tokenize plus minus operator", (function () {
                var tokens = LambdaParser.tokenize("5 - 2");
                var tokenStrings = LambdaParser.printTokens(tokens);
                expect(tokenStrings).toContain("5");
                expect(tokenStrings).toContain("-");
                expect(tokenStrings).toContain("2");
                expect(tokenStrings).toContain("EOF");
              }));
        test("parse simple integer", (function () {
                var expr = LambdaParser.parse("42");
                var printed = LambdaCompile.Print.printLam(expr);
                expect(printed).toBe("42");
              }));
        test("parse plus binary operator", (function () {
                var expr = LambdaParser.parse("1 + 2");
                var printed = LambdaCompile.Print.printLam(expr);
                expect(printed).toBe("(1 + 2)");
              }));
        test("parse minus binary operator", (function () {
                var expr = LambdaParser.parse("5 - 2");
                var printed = LambdaCompile.Print.printLam(expr);
                expect(printed).toBe("(5 - 2)");
              }));
        test("parse complex binary operators", (function () {
                var expr = LambdaParser.parse("10 - 5 + 2");
                var printed = LambdaCompile.Print.printLam(expr);
                expect(printed).toBe("((10 - 5) + 2)");
              }));
        test("parse simple variable", (function () {
                var expr = LambdaParser.parse("x");
                var printed = LambdaCompile.Print.printLam(expr);
                expect(printed).toBe("x");
              }));
        test("parse identity function", (function () {
                var expr = LambdaParser.parse("λx.x");
                var printed = LambdaCompile.Print.printLam(expr);
                expect(printed).toBe("(λx. x)");
              }));
        test("parse parenthesized expression", (function () {
                var expr = LambdaParser.parse("(x)");
                var printed = LambdaCompile.Print.printLam(expr);
                expect(printed).toBe("x");
              }));
        test("parse and compile identity function", (function () {
                var compiled = LambdaParser.parseAndCompile("λx.x");
                var printed = LambdaCompile.Print.printANF(compiled);
                expect(printed).toContain("fun");
                expect(printed).toContain("halt");
              }));
        test("parse and compile to LLVM", (function () {
                var llvm = LambdaParser.parseAndCompileToLLVM("42", 1);
                expect(llvm).toContain("ret i64 42");
                expect(llvm).toContain("define i64 @main()");
              }));
        test("parse and compile lambda to LLVM", (function () {
                var llvm = LambdaParser.parseAndCompileToLLVM("λx.x", 2);
                expect(llvm).toContain("define i64");
                expect(llvm).toContain("ret i64");
              }));
        test("integration with corrected hoisting - no join points", (function () {
                var compiled = LambdaParser.parseAndCompile("λx.x");
                var printed = LambdaCompile.Print.printANF(compiled);
                expect(printed).toContain("fun");
                expect(printed).not.toContain("join");
                expect(printed).not.toContain("jump");
              }));
        test("parser error handling", (function () {
                expect(function () {
                        return LambdaParser.parse("λ.x");
                      }).toThrow();
                expect(function () {
                        return LambdaParser.parse("λx");
                      }).toThrow();
                expect(function () {
                        return LambdaParser.parse("(x");
                      }).toThrow();
              }));
        test("complex expression parsing", (function () {
                var expr = LambdaParser.parse("λf.λx.x");
                var printed = LambdaCompile.Print.printLam(expr);
                expect(printed).toContain("λf");
                expect(printed).toContain("λx");
              }));
      }));

describe("Parser Integration with Corrected Hoisting", (function () {
        test("end-to-end: parse -> compile -> LLVM with corrected hoisting", (function () {
                var expr = LambdaParser.parse("λx.x");
                expect(LambdaCompile.Print.printLam(expr)).toBe("(λx. x)");
                var compiled = LambdaCompile.Compiler.compile(expr);
                var anfPrinted = LambdaCompile.Print.printANF(compiled);
                expect(anfPrinted).not.toContain("join");
                expect(anfPrinted).not.toContain("jump");
                var llvm = LambdaCompile.Compiler.compileToLLVM(expr, 2);
                expect(llvm).toContain("define i64");
                expect(llvm).toContain("ret i64");
                console.log("✅ End-to-end test passed: Parser + Corrected Hoisting + LLVM");
              }));
        test("parser enables text-based lambda calculus programming", (function () {
                var programs = [
                  [
                    "42",
                    "Simple integer"
                  ],
                  [
                    "x",
                    "Variable"
                  ],
                  [
                    "λx.x",
                    "Identity function"
                  ],
                  [
                    "λf.λx.x",
                    "Nested lambda"
                  ]
                ];
                programs.forEach(function (param) {
                      var description = param[1];
                      var program = param[0];
                      console.log("Testing: " + description + " - \"" + program + "\"");
                      var expr = LambdaParser.parse(program);
                      var compiled = LambdaCompile.Compiler.compile(expr);
                      var printed = LambdaCompile.Print.printANF(compiled);
                      expect(printed).not.toContain("join");
                      console.log("✅ " + description + " compiled successfully");
                    });
              }));
      }));

export {
  
}
/*  Not a pure module */
