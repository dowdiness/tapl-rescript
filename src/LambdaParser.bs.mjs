// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Core__List from "@rescript/core/src/Core__List.bs.mjs";
import * as LambdaCompile from "./LambdaCompile.bs.mjs";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

var ParseError = /* @__PURE__ */Caml_exceptions.create("LambdaParser.ParseError");

function printToken(token) {
  if (typeof token === "object") {
    if (token.TAG === "Identifier") {
      return token._0;
    } else {
      return token._0.toString();
    }
  }
  switch (token) {
    case "Lambda" :
        return "λ";
    case "Dot" :
        return ".";
    case "LeftParen" :
        return "(";
    case "RightParen" :
        return ")";
    case "Plus" :
        return "+";
    case "Minus" :
        return "-";
    case "If" :
        return "if";
    case "Then" :
        return "then";
    case "Else" :
        return "else";
    case "EOF" :
        return "EOF";
    
  }
}

function printTokens(tokens) {
  var tokens$1 = Core__List.toArray(Core__List.map(tokens, printToken)).join(", ");
  return "[" + tokens$1 + "]";
}

function tokenizeHelper(input, _pos, _acc) {
  while(true) {
    var acc = _acc;
    var pos = _pos;
    if (pos >= input.length) {
      return Core__List.reverse({
                  hd: "EOF",
                  tl: acc
                });
    }
    var c = input.charAt(pos);
    var exit = 0;
    switch (c) {
      case "(" :
          _acc = {
            hd: "LeftParen",
            tl: acc
          };
          _pos = pos + 1 | 0;
          continue ;
      case ")" :
          _acc = {
            hd: "RightParen",
            tl: acc
          };
          _pos = pos + 1 | 0;
          continue ;
      case "+" :
          _acc = {
            hd: "Plus",
            tl: acc
          };
          _pos = pos + 1 | 0;
          continue ;
      case "-" :
          _acc = {
            hd: "Minus",
            tl: acc
          };
          _pos = pos + 1 | 0;
          continue ;
      case "." :
          _acc = {
            hd: "Dot",
            tl: acc
          };
          _pos = pos + 1 | 0;
          continue ;
      case " " :
      case "\n" :
      case "\r" :
      case "\t" :
          exit = 1;
          break;
      case "\\" :
      case "λ" :
          exit = 2;
          break;
      default:
        var code = c.charCodeAt(0) | 0;
        if (code >= 65 && code <= 90 || code >= 97 && code <= 122) {
          var match = readIdentifier(input, pos, "");
          var identifier = match[1];
          var token;
          switch (identifier) {
            case "else" :
                token = "Else";
                break;
            case "if" :
                token = "If";
                break;
            case "then" :
                token = "Then";
                break;
            default:
              token = {
                TAG: "Identifier",
                _0: identifier
              };
          }
          _acc = {
            hd: token,
            tl: acc
          };
          _pos = match[0];
          continue ;
        }
        if (code >= 48 && code <= 57) {
          var match$1 = readNumber(input, pos, 0);
          _acc = {
            hd: {
              TAG: "Integer",
              _0: match$1[1]
            },
            tl: acc
          };
          _pos = match$1[0];
          continue ;
        }
        throw {
              RE_EXN_ID: ParseError,
              _1: "Unexpected character: " + c,
              Error: new Error()
            };
    }
    switch (exit) {
      case 1 :
          _pos = pos + 1 | 0;
          continue ;
      case 2 :
          _acc = {
            hd: "Lambda",
            tl: acc
          };
          _pos = pos + 1 | 0;
          continue ;
      
    }
  };
}

function readIdentifier(input, _pos, _acc) {
  while(true) {
    var acc = _acc;
    var pos = _pos;
    if (pos >= input.length) {
      return [
              pos,
              acc
            ];
    }
    var c = input.charAt(pos);
    var code = c.charCodeAt(0) | 0;
    if (!(code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 48 && code <= 57)) {
      return [
              pos,
              acc
            ];
    }
    _acc = acc + c;
    _pos = pos + 1 | 0;
    continue ;
  };
}

function readNumber(input, _pos, _acc) {
  while(true) {
    var acc = _acc;
    var pos = _pos;
    if (pos >= input.length) {
      return [
              pos,
              acc
            ];
    }
    var c = input.charAt(pos);
    var code = c.charCodeAt(0) | 0;
    if (!(code >= 48 && code <= 57)) {
      return [
              pos,
              acc
            ];
    }
    var digit = code - 48 | 0;
    _acc = Math.imul(acc, 10) + digit | 0;
    _pos = pos + 1 | 0;
    continue ;
  };
}

function tokenize(input) {
  return tokenizeHelper(input, 0, /* [] */0);
}

function makeParser(tokens) {
  return {
          tokens: tokens,
          position: 0
        };
}

function peek(parser) {
  var token = Core__List.get(parser.tokens, parser.position);
  if (token !== undefined) {
    return token;
  } else {
    return "EOF";
  }
}

function advance(parser) {
  return {
          tokens: parser.tokens,
          position: parser.position + 1 | 0
        };
}

function expect(parser, expected) {
  var current = peek(parser);
  if (Caml_obj.notequal(current, expected)) {
    throw {
          RE_EXN_ID: ParseError,
          _1: "Expected " + printToken(expected) + ", but get " + printToken(current),
          Error: new Error()
        };
  }
  return advance(parser);
}

function parse(input) {
  var tokens = tokenize(input);
  var parser = {
    tokens: tokens,
    position: 0
  };
  var parseAtom = function (parser) {
    var n = peek(parser);
    if (typeof n === "object") {
      if (n.TAG === "Identifier") {
        return [
                advance(parser),
                {
                  TAG: "Var",
                  _0: n._0
                }
              ];
      } else {
        return [
                advance(parser),
                {
                  TAG: "Int",
                  _0: n._0
                }
              ];
      }
    }
    switch (n) {
      case "Lambda" :
          var parser$1 = advance(parser);
          var param = peek(parser$1);
          if (typeof param !== "object") {
            throw {
                  RE_EXN_ID: ParseError,
                  _1: "Expected parameter after λ",
                  Error: new Error()
                };
          }
          if (param.TAG === "Identifier") {
            var parser$2 = advance(parser$1);
            var parser$3 = expect(parser$2, "Dot");
            var match = parseBinaryOp(parser$3);
            return [
                    match[0],
                    {
                      TAG: "Lam",
                      _0: param._0,
                      _1: match[1]
                    }
                  ];
          }
          throw {
                RE_EXN_ID: ParseError,
                _1: "Expected parameter after λ",
                Error: new Error()
              };
      case "LeftParen" :
          var parser$4 = advance(parser);
          var match$1 = parseBinaryOp(parser$4);
          var parser$5 = expect(match$1[0], "RightParen");
          return [
                  parser$5,
                  match$1[1]
                ];
      case "If" :
          var parser$6 = advance(parser);
          var match$2 = parseBinaryOp(parser$6);
          var parser$7 = expect(match$2[0], "Then");
          var match$3 = parseBinaryOp(parser$7);
          var parser$8 = expect(match$3[0], "Else");
          var match$4 = parseBinaryOp(parser$8);
          return [
                  match$4[0],
                  {
                    TAG: "If",
                    _0: match$2[1],
                    _1: match$3[1],
                    _2: match$4[1]
                  }
                ];
      default:
        throw {
              RE_EXN_ID: ParseError,
              _1: "Unexpected token: " + printToken(n),
              Error: new Error()
            };
    }
  };
  var parseBinaryOp = function (parser) {
    var match = parseApplication(parser);
    var _parser = match[0];
    var _acc = match[1];
    while(true) {
      var acc = _acc;
      var parser$1 = _parser;
      var match$1 = peek(parser$1);
      if (typeof match$1 === "object") {
        return [
                parser$1,
                acc
              ];
      }
      switch (match$1) {
        case "Plus" :
            var parser$2 = advance(parser$1);
            var match$2 = parseApplication(parser$2);
            _acc = {
              TAG: "Bop",
              _0: "Plus",
              _1: acc,
              _2: match$2[1]
            };
            _parser = match$2[0];
            continue ;
        case "Minus" :
            var parser$3 = advance(parser$1);
            var match$3 = parseApplication(parser$3);
            _acc = {
              TAG: "Bop",
              _0: "Minus",
              _1: acc,
              _2: match$3[1]
            };
            _parser = match$3[0];
            continue ;
        default:
          return [
                  parser$1,
                  acc
                ];
      }
    };
  };
  var parseApplication = function (parser) {
    var match = parseAtom(parser);
    var _parser = match[0];
    var _acc = match[1];
    while(true) {
      var acc = _acc;
      var parser$1 = _parser;
      var match$1 = peek(parser$1);
      if (typeof match$1 !== "object") {
        switch (match$1) {
          case "Lambda" :
          case "LeftParen" :
              break;
          default:
            return [
                    parser$1,
                    acc
                  ];
        }
      } else {
        match$1.TAG === "Identifier";
      }
      var match$2 = parseAtom(parser$1);
      _acc = {
        TAG: "App",
        _0: acc,
        _1: match$2[1]
      };
      _parser = match$2[0];
      continue ;
    };
  };
  var match = parseBinaryOp(parser);
  var match$1 = peek(match[0]);
  if (typeof match$1 !== "object") {
    if (match$1 === "EOF") {
      return match[1];
    }
    throw {
          RE_EXN_ID: ParseError,
          _1: "Unexpected tokens after expression",
          Error: new Error()
        };
  } else {
    throw {
          RE_EXN_ID: ParseError,
          _1: "Unexpected tokens after expression",
          Error: new Error()
        };
  }
}

function parseAndCompile(input) {
  return LambdaCompile.Compiler.compile(parse(input));
}

function parseAndCompileToLLVM(input, phase) {
  return LambdaCompile.Compiler.compileToLLVM(parse(input), phase);
}

function testParser() {
  console.log("Testing enhanced parser with binary operators...");
  var tokens1 = tokenize("1 + 2");
  console.log("Tokens for '1 + 2': " + printTokens(tokens1));
  var tokens2 = tokenize("λx.x + 1");
  console.log("Tokens for 'λx.x + 1': " + printTokens(tokens2));
  var tokens3 = tokenize("3 - 1 + 2");
  console.log("Tokens for '3 - 1 + 2': " + printTokens(tokens3));
  var expr1 = parse("42");
  console.log("Parsed '42': " + LambdaCompile.Print.printLam(expr1));
  var expr2 = parse("x");
  console.log("Parsed 'x': " + LambdaCompile.Print.printLam(expr2));
  var expr3 = parse("λx.x");
  console.log("Parsed 'λx.x': " + LambdaCompile.Print.printLam(expr3));
  var expr4 = parse("1 + 2");
  console.log("Parsed '1 + 2': " + LambdaCompile.Print.printLam(expr4));
  var expr5 = parse("5 - 3");
  console.log("Parsed '5 - 3': " + LambdaCompile.Print.printLam(expr5));
  var expr6 = parse("1 + 2 + 3");
  console.log("Parsed '1 + 2 + 3': " + LambdaCompile.Print.printLam(expr6));
  var expr7 = parse("10 - 5 + 2");
  console.log("Parsed '10 - 5 + 2': " + LambdaCompile.Print.printLam(expr7));
  var expr8 = parse("(1 + 2) + 3");
  console.log("Parsed '(1 + 2) + 3': " + LambdaCompile.Print.printLam(expr8));
  var expr9 = parse("λx.x + 1");
  console.log("Parsed 'λx.x + 1': " + LambdaCompile.Print.printLam(expr9));
  var expr10 = parse("if 1 then 2 else 3");
  console.log("Parsed 'if 1 then 2 else 3': " + LambdaCompile.Print.printLam(expr10));
  var compiled1 = parseAndCompile("1 + 2");
  console.log("Compiled '1 + 2': " + LambdaCompile.Print.printANF(compiled1));
  var compiled2 = parseAndCompile("λx.x + 1");
  console.log("Compiled 'λx.x + 1': " + LambdaCompile.Print.printANF(compiled2));
  console.log("Enhanced parser tests completed!");
}

export {
  ParseError ,
  printToken ,
  printTokens ,
  tokenizeHelper ,
  readIdentifier ,
  readNumber ,
  tokenize ,
  makeParser ,
  peek ,
  advance ,
  expect ,
  parse ,
  parseAndCompile ,
  parseAndCompileToLLVM ,
  testParser ,
}
/* LambdaCompile Not a pure module */
